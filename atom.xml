<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road to PI/2</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="tangenta.github.io/"/>
  <updated>2018-01-24T09:59:53.673Z</updated>
  <id>tangenta.github.io/</id>
  
  <author>
    <name>tangenta</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TLPI-系统编程概念</title>
    <link href="tangenta.github.io/2018/01/21/TLPI-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>tangenta.github.io/2018/01/21/TLPI-系统编程概念/</id>
    <published>2018-01-21T03:15:00.000Z</published>
    <updated>2018-01-24T09:59:53.673Z</updated>
    
    <content type="html"><![CDATA[<p>system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。</p><a id="more"></a><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统函数（system call）是进程向内核请求服务的入口，是系统编程的接口（API）。内核提供各种各样的服务，例如创建新进程、实行IO操作、进程间通信等等。</p><p>系统调用有如下特征：</p><ul><li>每次进行系统调用，都会将处理器的状态从“用户模式”转换为“内核模式”。</li><li>系统函数的集合是固定的，每个系统函数都由独一无二的数字标识。</li><li>每个系统函数原型都包含一个或多个形参。</li></ul><p>在C语言中，系统函数调用的过程：</p><ol><li>调用C函数库中的封装函数</li><li>封装函数保证调用系统函数时对应参数位置的正确性</li><li>调用系统函数前，封装函数将系统函数对应的数字赋值到寄存器eax中</li><li>执行trap机器指令（0x80），导致程序计数器跳转到0x80，处理器模式也从用户模式转换为内核模式</li><li>开始调用system_call()。它作出下列行为：<ul><li>寄存器的值入栈。</li><li>检验系统调用的合法性。</li><li>根据sys_call_table找到并调用相应的系统函数。</li><li>恢复寄存器值，系统函数的返回值入栈。</li><li>返回到封装函数，切换模式。</li></ul></li><li>系统调用被反应到全局变量errno，从封装函数返回</li></ol><p>[注] 通常情况下，调用系统函数的开销是普通函数的数十倍。</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>库函数是C标准库中的重要组成部分。其中既包括与系统函数无关的函数，例如字符串处理函数; 又有系统函数的封装器，例如fopen，printf，malloc，free等等——这类库函数通常为简化系统函数的使用而被设计出来。</p><h3 id="系统-库函数的错误处理"><a href="#系统-库函数的错误处理" class="headerlink" title="系统/库函数的错误处理"></a>系统/库函数的错误处理</h3><p>除了测试返回值以外，多数系统函数在出现异常时会设置全局变量errno（通常与<code>&lt;errno.h&gt;</code>中定义的常量配合使用）。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cnt = read(fd, buf, numbytes);</div><div class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>) &#123;</div><div class="line"><span class="keyword">if</span> (errno == EINTR)</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read was interrupted by a signal\n"</span>);</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">/* Some other error occurred */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>&lt;errno.h&gt;</code>中定义的所有表示错误的常量都以E开头。man手册中，每一个系统函数的ERRORS部分标注了所有可能产生的错误。例如close(int fd)：</p><p><img src="/images/systemconcept-close-error.png" alt="upload successful"></p><p>[注意] errno表示<strong>上一次</strong>错误的数字代号。也就是说，如果系统调用正常返回，它不会对errno进行重设。因此，在使用errno之前，都应当先检查返回值。<br>此外，还有一种常见的错误使用errno的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"somacall() failed\n"</span>);</div><div class="line">    <span class="keyword">if</span> (errno == ...) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>错误之处在于printf可能会重设errno。用C++的话来说，这不是异常安全的。<br>正确写法是第一步先保存errno的值。</p><p>[注意] 不要手动声明errno(即<code>extern int errno;</code>)，而应该使用<code>#include &lt;errno.h&gt;</code>的方式声明。</p><h4 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg )</span></span>;</div></pre></td></tr></table></figure><p>输出字符串msg和errno对应的描述到标准错误流上。</p><p><img src="/images/systemconcept-perror.png" alt="upload successful"></p><h4 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns pointer to error string corresponding to errnum</span></div></pre></td></tr></table></figure><p>遇到未知错误代码时，返回的字符串为“unknown error nnn”。但在一些strerror实现中，也有可能是NULL。</p><p><img src="/images/systemconcept-strerror.png" alt="upload successful"></p><p>[注意] 部分库函数遇到错误不会设置errno，这种情况下，不应使用perror()或strerror()来检查错误。</p><h3 id="常用头文件和错误处理函数"><a href="#常用头文件和错误处理函数" class="headerlink" title="常用头文件和错误处理函数"></a>常用头文件和错误处理函数</h3><p>perror和strerror功能分别是输出错误信息和翻译错误码，但在linux系统编程中仅仅有这两个是不够方便的。下面给出几个实用的错误报告函数（它们的实现在这里：<a href="https://gitee.com/tangenta/TLPI-study-notes/blob/master/tlpi_hdr.h" target="_blank" rel="external">tlpi-hdr.h</a>）：</p><ul><li><strong><code>void errMsg(const char* format, ...)</code></strong>： 有格式控制输出的perror()</li><li><strong><code>void errExit(const char* format, ...)</code></strong>： errMsg后退出程序</li><li><strong><code>void err_exit(const char* format, ...)</code></strong>： 类似errExit，退出时<strong>不刷新</strong>stdout缓冲区</li><li><strong><code>void errExitEN(int errnum, const char* format, ...)</code></strong>： 用errnum代替errno的errExit(多线程中，errno是函数调用，使用errExitEN()有利于提高效率)</li><li><strong><code>void fatal(const char* format, ...)</code></strong>： 用来诊断通用错误（即包括不会设置errno的错误），<strong>不使用</strong>errno，采用errExit退出程序。</li><li><strong><code>void usageErr(const char* format, ...)</code></strong>： 字符串前置”Usage:”</li><li><strong><code>void cmdLineErr(const char* format, ...)</code></strong>： 用于表示命令行参数错误</li></ul><p>下面是命令行解析函数（分别是int和long）：</p><ul><li><strong><code>int getInt(const char* arg , int flags , const char* name)</code></strong></li><li><strong><code>long getLong(const char* arg , int flags , const char* name)</code></strong></li></ul><p>如果arg指向的字符串不能被转换为整数，则报错并终止程序。</p><p>flag可以设定<strong>大小</strong>——非负(GN_NONNEG)、正(GN_GT_0)和<strong>进制</strong>——任意进制(GN_ANY_BASE)、八进制(GN_BASE_8)、十六进制(GN_BASE_16)。大小和进制可以用或（|）来同时设定。</p><p>name可以自己设定，输出结果以…(in <em>name</em>)…显示。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul><li><p>特性检测宏(feature test macros)</p><p>  由于不同的标准主导了系统函数和库函数的API，要使程序具有可移植性，就要做到在头文件中只暴露某些平台相关的定义。</p><p>  可以通过<code>#define xxx</code>或者在编译选项加上<code>-D xxx</code>，让程序得以在遵循这些标准的系统上正常运行。</p></li><li><p>系统数据类型(system data type)</p><p>  我们常常可以看到一些typedef，例如size_t，pid_t等等，应用这些数据类型而非直接使用C语言中的int，long的原因就是能够提高可移植性。例如存放进程ID，有些系统需要4个字节的空间，另一些则用8个字节。我们写程序时可以用pid_t来消除“用int还是long”的麻烦。</p><p>  用printf输出这些数据类型时，由于程序在运行时无法得知“系统数据类型”对应的“C类型”，用”%d”还是用”%ld”就成了问题。一个解决方案是，对所有系统数据类型变量先强制转换为long，以”%ld”的形式输出。</p></li></ul><ul><li><p>结构体</p><p>  一些标准中的部分结构体没有指定内部成员的相对次序。在初始化时，为了提高可移植性，不应使用 <code>struct somestruct s = {a1, a2, a3}</code> 这种形式，而应显式初始化。</p></li></ul><ul><li><p>非通用的宏</p><p>  有些宏不是在所有实现都有定义。使用它们的时候应用<code>#ifdef xxx</code>包裹起来。</p></li><li><p>头文件</p><p>  同一个定义在不同的标准下，可能会位于不同的头文件中。为了尽可能提高可移植性，可以考虑包含多个标准指定的头文件。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="TLPI" scheme="tangenta.github.io/tags/TLPI/"/>
    
  </entry>
  
  <entry>
    <title>GDB奇技淫巧</title>
    <link href="tangenta.github.io/2017/12/26/gdb-trick/"/>
    <id>tangenta.github.io/2017/12/26/gdb-trick/</id>
    <published>2017-12-26T02:00:00.000Z</published>
    <updated>2018-01-24T09:53:40.879Z</updated>
    
    <content type="html"><![CDATA[<p>学会了这个，调试速度马上提高1.005倍！点击阅读原文</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="执行外部shell命令"><a href="#执行外部shell命令" class="headerlink" title="执行外部shell命令"></a>执行外部shell命令</h3><p>在不退出gdb的情况下执行/bin/sh命令(无视alias，用起来可能不是特别方便)：</p><p><code>(gdb)!clang++ test.cpp -o test</code> </p><p>或者</p><p><code>(gdb)shell clang++ test.cpp -o test</code></p><hr><h3 id="记录调试信息"><a href="#记录调试信息" class="headerlink" title="记录调试信息"></a>记录调试信息</h3><p>将调试产生的输出保存到文件中(file默认是gdb.txt)，便于日后分析：</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set logging on/off</td><td>调试信息记录开启/关闭</td></tr><tr><td>set logging file [file]</td><td>设置保存记录的文件名</td></tr></tbody></table><hr><h3 id="设置程序启动参数"><a href="#设置程序启动参数" class="headerlink" title="设置程序启动参数"></a>设置程序启动参数</h3><p>程序运行参数太多，每次run要写一堆参数？exec-wrapper或args解放双手：</p><ul><li>exec-wrapper：存放了用于启动程序的shell命令。在gdb中运行run时，通过exec-wrapper来启动程序，然后将控制权转交给gdb。如果exec-wrapper为空，则会执行已被连接的target(即默认情况)。</li><li>args：存放了需要传递给被调试程序的参数。运行run时，args内的字符串被当作参数传递给程序。</li></ul><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>show args</td><td>显示run附带的参数</td></tr><tr><td>show exec-wrapper</td><td>显示exec-wrapper的内容</td></tr><tr><td>set exec-wrapper “./a.out -arg”</td><td>设置启动命令为”./a.out -arg”</td></tr><tr><td>set args “-arg1 -arg2 -arg3”</td><td>设置运行参数为”-arg1 -arg2 -arg3”</td></tr><tr><td>unset exec-wrapper</td><td>删除exec-wrapper</td></tr></tbody></table><hr><h3 id="存档机制"><a href="#存档机制" class="headerlink" title="存档机制"></a>存档机制</h3><p>调试错过了翻车地点？存档机制逆转时空，restart一下就好了，不必重新运行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>checkpoint</td><td>保存当前程序状态(通过fork实现)</td></tr><tr><td>info checkpoints</td><td>查看存档信息(每个checkpoint都有自己的id)</td></tr><tr><td>restart checkpoint-id</td><td>恢复第checkpoint-id个存档的信息</td></tr><tr><td>delete checkpoint checkpoint-id</td><td>删除第checkpoint-id个存档的信息</td></tr></tbody></table><p>注意：恢复程序的状态不包括恢复pid值、对外部文件或进程的操作。例如打印到文件流的信息不能被吸回来，删掉的外部文件不能被恢复，等等。</p><hr><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><h4 id="断点的设置-删除"><a href="#断点的设置-删除" class="headerlink" title="断点的设置/删除"></a>断点的设置/删除</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>tbreak</td><td>一次性断点，用完自动删除</td></tr><tr><td>rbreak <em>regex</em></td><td>正则断点，匹配满足条件的名字</td></tr><tr><td>break 5 if <em>condition</em></td><td>在第5行设置一个断点，满足condition时暂停程序</td></tr><tr><td>watch [-location] <em>expr</em></td><td>数据断点，当expr[-location:指向]的值发生改变时暂停程序</td></tr><tr><td>rwatch [-location] <em>expr</em></td><td>数据断点，expr被读取时暂停程序</td></tr><tr><td>awatch [-l] <em>expr</em></td><td>数据断点，expr被读取或写入时暂停程序</td></tr><tr><td>clear [filename:]function/linenum</td><td>删除函数或行号上的所有断点</td></tr><tr><td>delete</td><td>删除所有断点</td></tr></tbody></table><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>condition <em>bnum</em> <em>expr</em></td><td>在第bnum个断点上设置程序暂停条件expr</td></tr><tr><td>condition <em>bnum</em></td><td>取消第bnum个断点的程序暂停条件</td></tr><tr><td>ignore <em>bnum</em> <em>count</em></td><td>第bnum个断点被触发count次后暂停程序</td></tr></tbody></table><h4 id="断点命令commands…end"><a href="#断点命令commands…end" class="headerlink" title="断点命令commands…end:"></a>断点命令commands…end:</h4><p>遇到断点时，执行command和end之间的命令。<br>command和end分别用于标记断点命令表的开始和结束，而主体部分的命令将绑定在最近设置的断点上。例如：</p><pre><code>(gdb)break 7(gdb)commandssilentprintf &quot;x is %d\n&quot;, xcontinueend</code></pre><p>在编号为7的断点上设置了断点命令——slient(静默处理断点停止信息)、printf(输出x的值)、continue(继续运行程序)。</p><h4 id="断点的保存-恢复"><a href="#断点的保存-恢复" class="headerlink" title="断点的保存/恢复"></a>断点的保存/恢复</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>save breakpoints <em>filename</em></td><td>以命令的形式将所有断点保存到文件中</td></tr><tr><td>source <em>filename</em></td><td>执行filename文件的内容(这里是恢复断点)</td></tr></tbody></table><hr><h3 id="恢复运行与单步调试"><a href="#恢复运行与单步调试" class="headerlink" title="恢复运行与单步调试"></a>恢复运行与单步调试</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>continue<br> step [count]<br> next [count]<br> finish<br> until [count]</td><td>常规操作</td></tr><tr><td>until</td><td>继续运行程序，直到后一条指令被执行为止</td></tr><tr><td>stepi<br> si</td><td>执行一条机器指令，进入函数(如果有)</td></tr><tr><td>nexti<br> ni</td><td>执行一条机器指令，不进入函数</td></tr><tr><td>skip <em>file</em><br> skip <em>function</em></td><td>跳过不需要调试的文件/函数</td></tr><tr><td>skip enable/disable/delete [range]</td><td>启用/禁用/删除skips</td></tr></tbody></table><ul><li>until：这里的后一条指令是指，以内存地址值大小的”小于”作为指令的偏序关系，当前指令的最小上界。主要用于跳出循环。注意：如果看到执行完until的效果是，执行的语句反而”倒退”了，则很可能是编译器进行了机器指令位置上的调整(例如while改为了do-while)。</li></ul><hr><h3 id="录制与回放"><a href="#录制与回放" class="headerlink" title="录制与回放"></a>录制与回放</h3><p>将问题锁定在程序的某个区间后，如果需要反复逐条指令地运行这一段代码，可以采用gdb提供的录制回放功能。</p><p>gdb录制-回放模式: 在这个模式中，如果下一条指令已在记录中，gdb会以回放模式执行该指令(即并非真正运行该指令，而是从记录中读取与这条指令相关的信息，改变程序状态)。否则，gdb以录制模式执行该指令(将与之关联的信息保存到记录中)。多数情况下，回放模式支持逆行。以下是相关命令：</p><ul><li><p><strong>record <em>method</em></strong> 启用录制-回放模式，其中”<em>method</em>“可被以下参数代替：</p><ul><li><strong>full(default)</strong> 使用软件实现录制和回放，支持逆行。(随手测试100多条C++语句，产生大约3M的信息)</li><li><strong>btrace <em>format</em></strong><br>使用硬件支持录制状态。录制的内容不能保存到文件中;数据被保存在一个环状缓冲区——如果缓冲区已满，则会覆盖前面的数据。<em>format</em>可以被以下参数代替:<ul><li><strong>bts</strong> Branch trace store录制格式，储存每一个分支。</li><li><strong>pt</strong> Intel processor trace录制格式，储存之前经过压缩。</li></ul></li></ul><p>full方式不能用在non-stop mode和asynchronous execution mode。它们只能支持btrace方式。(?_?)</p></li><li><strong>record stop</strong> 删除所有记录，并退出录制-回放模式。</li><li><strong>record delete</strong> 抛弃前面录制的所有内容，从当前指令重新开始录制</li><li><strong>record goto <em>location</em></strong> 读取特定位置的记录。<em>location</em>可被以下参数代替：<ul><li><strong>begin/start</strong> 开始</li><li><strong>end</strong> 结束</li><li><strong>n</strong> 第n个指令</li></ul></li><li><strong>record save <em>filename</em></strong> 将记录存到filename文件中，默认为gdb_record.process_id。</li><li><strong>record restore <em>filename</em></strong> 从filename文件中读取记录。</li></ul><p>杂项：</p><ul><li><strong>set/show record full insn-number-max <em>limit</em></strong> 设置/查看最大记录指令数，<em>limit</em>可以为正整数或”unlimited”。</li><li><strong>set/show full stop-at-limit</strong> 指令数达到最大记录时，暂停程序</li><li><strong>set/show record btrace bts/pt buffer-size</strong> 设置btrace方式的缓冲区容量</li><li><strong>record instruction-history *</strong> 对录制的指令反汇编及相关操作</li></ul><h3 id="逆行"><a href="#逆行" class="headerlink" title="逆行"></a>逆行</h3><p>调试过程中的逆行，可以使程序逐步恢复到执行各指令之前的状态，包括寄存器、内存、输入输出设备等。一般情况下，在回放模式中可以逆行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set exec-direction forward/reverse</td><td>设置程序的运行方式为正向/逆向</td></tr><tr><td>reverse-<em>command</em></td><td>以逆向的方式执行<em>command</em>命令</td></tr></tbody></table><p>注意：上面的command可以被continue / step / stepi / next / nexti / finish任何一条命令替换。另外，如果exec-direction被设置为了逆向(reverse)，”<em>command</em>“和”reverse-<em>command</em>“的功能也被对换。</p><hr><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>backtrace full [n/-n] bt full [n/-n]</td><td>展示[最内/外n层的]栈回溯和局部变量</td></tr><tr><td>frame n f n</td><td>选择第n个函数栈</td></tr><tr><td>up/down n</td><td>进入上n级/下n级函数栈，n缺省为1</td></tr><tr><td>info frame info f</td><td>显示当前函数栈的详细信息，包括： 上/下级栈地址、源代码语言、函数参数地址、局部变量地址、上级函数栈指针sp、被保存的寄存器地址</td></tr><tr><td>info args/locals</td><td>显示函数参数/局部变量的信息 </td></tr></tbody></table><hr><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>disassemble /s</td><td>同时展示源代码和汇编代码</td></tr><tr><td>disassemble /r</td><td>同时展示机器代码和汇编代码</td></tr><tr><td>disassemble <em>begin</em>, <em>end</em></td><td>展示从begin到end的汇编代码</td></tr></tbody></table><hr><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul><li>类型检验/转换<ul><li><strong>ptype exp</strong> ：给定某个表达式，检验其运算结果的类型。如果exp是用户自定义类型，则输出该类型的源码; 如果是函数，则输出函数原型。</li><li><strong>p {type} addr</strong> ：以类型“type”输出地址“addr”的内容。比如：<code>p {int}0x618c20</code> 的含义是：将0x618c20处的内容“强制转换”为int，输出。</li></ul></li><li><p>数组访问</p><ul><li><strong>p *array@len</strong> ：表达式“*array@len”的结果是一个长度为len的数组，类型由array决定。其中“@”是一个二元运算符，左边是数组的第一个元素(必须在内存中)，右边是数组元素个数。</li><li><strong>p/x (type[])addr</strong> ：将addr强制转换为数组并输出。例如 <code>p (short[])0x12345678</code>的输出结果为$1 = {0x1234, 0x5678}。方括号内可以填入元素个数。</li><li><p>如果要访问的是指针数组中每个指针指向的对象，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set $i = 0</div><div class="line">p arr[$i++]-&gt;vp</div><div class="line">RET</div><div class="line">RET</div></pre></td></tr></table></figure><p>  其中RET是回车。</p></li></ul></li><li><p><strong>print/<em>format</em> val</strong>： 格式化输出val。其中format可以被以下字符代替：</p></li></ul><table><thead><tr><th>format</th><th>description</th></tr></thead><tbody><tr><td>x</td><td>int(hex)，十六进制整数</td></tr><tr><td>d</td><td>int(dec)，十进制整数</td></tr><tr><td>u</td><td>(unsigned)int，无符号整数</td></tr><tr><td>o</td><td>int(oct)，八进制整数</td></tr><tr><td>t</td><td>int(bin)，二进制整数</td></tr><tr><td>a</td><td>address，地址</td></tr><tr><td>c</td><td>char，字符</td></tr><tr><td>f</td><td>float，浮点数</td></tr><tr><td>s</td><td>string，尽可能转换为字符串</td></tr><tr><td>z</td><td>leading zero hex，十六进制整数，前面填充0</td></tr><tr><td>r</td><td>raw，原始形式</td></tr></tbody></table><ul><li><p><strong>x/<em>nfu</em> addr</strong>： 以一定的格式输出地址addr中的内容。</p><ul><li>n：repeat count，如果n是负数，则向前数-n个;     </li><li>f： format，和上述format含义相同; </li><li>u： unit size，可以是“b、h、w、g”中的一个，分别代表1、2、4、8个字节。</li></ul><p>执行完一条x addr命令以后，该结果临时保存在$_（美元符+1个下划线），addr的值临时保存在$__（美元符+2个下划线），方便下次取用。</p></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p>待填的坑：</p><ul><li>环境变量/工作目录/输入输出设备设置</li><li>远程调试正在运行的程序</li><li>多进程/多线程下的调试</li><li>catchpoint的使用</li><li>动态输出(dynamic printf)</li><li>静态探查点(static probe points)</li><li>信号</li><li>frame filter</li><li>动态连接程序的反汇编</li><li>数据类型探索(explore data)</li><li>convenience variables/functions</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学会了这个，调试速度马上提高1.005倍！点击阅读原文&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>真·「stack_overflow」</title>
    <link href="tangenta.github.io/2017/12/04/stack-overflow/"/>
    <id>tangenta.github.io/2017/12/04/stack-overflow/</id>
    <published>2017-12-04T12:09:00.000Z</published>
    <updated>2018-01-13T10:52:22.267Z</updated>
    
    <content type="html"><![CDATA[<p>前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的<a href="http://csapp.cs.cmu.edu/2e/home.html" target="_blank" rel="external">配套网站</a>和里面的<a href="http://csapp.cs.cmu.edu/2e/labs.html" target="_blank" rel="external">实验室</a>献上。。没有膝盖了，就点个赞吧。<br><a id="more"></a></p><hr><p>2018.01.13更新：初次实践，玩溢出的时候走了一些弯路：比如肉眼看内存状况，以及注入冗余代码等等。关于注入代码中的函数调用模拟：</p><blockquote><p>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">movl $0x1005b2b7,%eax</div><div class="line">pushl $0x8048dbe</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $0x38,%esp</div><div class="line">leave</div><div class="line">ret</div></pre></td></tr></table></figure></p></blockquote><p>这段说法存在问题。从代码分析可以发现，用于建立新函数栈的第3-5行可以和用于回收函数栈的第6行相互抵消。而ret的作用仅仅是pop返回地址+程序跳转，除了sp++之外，没有对栈结构造成其他影响。因此也没有“程序认为我们已经返回到了test中”这种说法。。</p><p>归根结底，还是对汇编指令与栈结构之间的联系理解得不够深刻。</p><hr><p>————原文分割线————</p><hr><p>栈溢出攻击：对于读入字符串时没有边界检查的程序，利用字符串不断写入信息覆盖返回值，使程序计数器跳转到指定位置，执行特定代码的行为。</p><p>下面是一个栗子(代码和图片都来自CSAPP)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> c;</div><div class="line"><span class="keyword">char</span> *dest = s;</div><div class="line"><span class="keyword">int</span> gotchar = <span class="number">0</span>; <span class="comment">/* Has at least one character been read? */</span></div><div class="line"><span class="keyword">while</span> ((c = getchar()) != ’\n’ &amp;&amp; c != EOF) &#123;</div><div class="line">*dest++ = c; <span class="comment">/* No bounds checking! */</span></div><div class="line">gotchar = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">*dest++ = ’\<span class="number">0</span>’; <span class="comment">/* Terminate string */</span></div><div class="line"><span class="keyword">if</span> (c == EOF &amp;&amp; !gotchar)</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* End of file or error */</span></div><div class="line"><span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Read input line and write it back */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></div><div class="line">gets(buf);</div><div class="line"><span class="built_in">puts</span>(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码经过gcc -m32编译过后产生一个在IA32处理器上运行的程序。<br>下图为程序执行到echo函数中的gets(buf)时的内存结构，地址数值从上往下递减。寄存器%ebp是echo的框架指针，并且白色矩形从上至下依次为：</p><ul><li>return address: 函数结束时的返回地址，即PC要跳转的地址;</li><li>saved %ebp: echo()调用者的框架指针;</li><li>saved %ebx: 具有callee-saved性质的寄存器保存的值;</li><li>buf[0]-buf[7]: 在栈上申请的空间，用于存放gets即将读入的字符串。<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></li></ul><p>栈溢出攻击要做的就是不断填入字符，一直延伸到返回地址并用“有效返回地址”覆盖它。这样函数在返回的时候PC就会跳转到我们想去的地方，执行想执行的命令，美滋滋。<br>好，今天就到此为止。</p><p><img src="/2017/12/04/stack-overflow/fakeEnd.png" width="100%" height="100%"></p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p><p>。。<br><br></p><p>到此为止是不可能到此的，这辈子都不可能到此为止，上面只是一个复习而已啦。下面开始进入正题：挽起袖子动手实现栈溢出。<br>原料：CSAPP实验室提供的bufbomb一枚，可以在Buffer Lab的Self-study Handout获得。<br>工具：gdb，objdump，gcc和脑子。</p><p>依题意得，该程序会调用下面的test函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</div><div class="line">val = getbuf();</div><div class="line"><span class="comment">/* Check for corrupted stack */</span></div><div class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</div><div class="line">validate(<span class="number">3</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">/* Buffer size for getbuf */</span></div><div class="line"> <span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">Gets(buf);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从命题人的角度分析，这个getbuf()是考察重点。鉴于它想用32个字节的数组容纳键盘输入的数据，看起来像个老实人，试探它一下：<br><img src="/2017/12/04/stack-overflow/typestring.png" width="80%" height="80%"><br>我写了34个字符还能让我走，果然是个老实人，可以欺负。</p><p>现在可以定一个小目标：通过外部输入，让test函数执行它的第二个条件分支语句<strong>else if (val == cookie) {…</strong></p><p>分析一下，要让首先要让val==cookie成立。(考虑到这是一个assignment，当然要有机制来防止抄袭，这里cookie就是一个根据用户名生成的一个值。这里我的用户名使用的是bovik，对应的cookie值是0x1005b2b7)<br>就是说，要把val改为0x1005b2b7。又观察到val = getfuf()，所以我们只需要把getbuf()的返回值从1改为0x1005b2b7就好了。</p><p>具体的流程是，取得程序的控制权-&gt;执行特定的机器指令-&gt;归还控制权。</p><p>首先，掏出工具看看getbuf的汇编代码：</p><blockquote><p><code>$ objdump -d bufbomb | grep -20 &quot;&lt;getbuf&gt;&quot;</code><br><img src="/2017/12/04/stack-overflow/getbuf.png" width="100%" height="100%"><br>可以看到进入函数以后，在栈分配了0x38字节的空间，其中0x28是用来放准备从键盘读入的字符(0x20)和上一级的框架指针位置ebp(0x8);最低的0x8用来存Gets的参数;中间空了的0x8不知道拿来干嘛的。。<br>值得一提的是，这个%eax存放的0x1就是目标，在注入的机器指令中要修改它的值。</p></blockquote><p>然后侦查一波，检查getbuf调用时的内存状况：</p><blockquote><p><code>$ gdb ./bufbomb</code>      #  进入gdb<br><code>(gdb) b getbuf</code>        #  在getbuf设置断点<br><code>(gdb) r -u bovik</code>    #  执行，这里的bovik就是用户名<br><img src="/2017/12/04/stack-overflow/bgetbuf.png" width="100%" height="100%"><br>cookie值：0x1005b2b7<br><img src="/2017/12/04/stack-overflow/stopAtGetbuf.png" width="100%" height="100%"><br>好，程序已经停在了断点处，可以开始观察了：<br><code>(gdb) info register</code> #  查看寄存器情况<br><img src="/2017/12/04/stack-overflow/infoRegis1.png" width="100%" height="100%"><br>主要关注ebp和esp。0xb0-0x78 == 0x38，和分析的一致，稳。<br>最关键的部分来了：内存现场<br><code>(gdb) x/80bx $esp</code>   #  以16进制查看从$esp开始，80个字节的内存情况<br><img src="/2017/12/04/stack-overflow/initMem.png" width="100%" height="100%"><br>白色高亮部分左边的0x556835b0就是当前框架指针ebp的值。<br>如果不出意外，这里包含了上级框架指针%ebp地址和返回地址。</p></blockquote><p>要取得程序的控制权，先要覆盖返回地址。要覆盖返回地址，就必须知道返回地址在哪。那我们先看看正常的返回地址长啥样，看test函数中调用getbuf的下一行：</p><blockquote><p><code>(gdb） disas test</code>    #  查看test的汇编代码<br><img src="/2017/12/04/stack-overflow/retAddr.png" width="100%" height="100%"><br>getbuf函数调用完之后，程序应该返回0x08048dbe;跟我念，08,04,8d,be。<br>趁着还没忘记，赶紧回到上一张图高亮部分，从后往前看：08..04..8d..be！！！果然没错，就是要覆盖掉这里！<br>(至于为什么要倒过来，这可能就是little endian的哲学了吧。)</p></blockquote><p>那输入要从哪开始呢？前面getbuf的汇编告诉我们，字符数组从-0x28(%ebp)开始，可以用gdb里面的计算器算一算：</p><blockquote><p><code>(gdb) p $ebp-0x28</code><br><code>$1 = (void *) 0x55683588 &lt;_reserved+1037704&gt;</code><br><img src="/2017/12/04/stack-overflow/stringAddr.png" width="100%" height="100%"><br>就是说，要填满32个字节之后，还要再填16个字节才能覆盖返回地址。</p></blockquote><p>下面就面临一个问题了：覆盖了返回地址，去哪？<br><br><br><br><br><br><br><br></p><p>当然是去能够执行我给它的机器指令的地方啊！<br>显然，能够注入的指令的地址位置在0x55683588+，那跳转到哪比较合适呢？这时有两个选择：</p><ul><li>一个是buf[]数组里面，没有副作用，不会腐蚀前一个函数的栈结构，但是能写入的机器指令也很有限：总不能越过刚刚覆盖完的返回地址吧(回到过去杀掉自己的感觉?_?)。</li><li>另一个是“覆盖返回地址位置”之后，即0x556835b8+，不过这样很可能腐蚀前一个函数的栈结构，把别人家捣烂了还想不被发现，有点难度。而且别忘了test函数还有个门卫：<strong>volatile int local = uniqueval();</strong>，要是碰到了这个东西就更麻烦了(当然也不是不可以，用注入的机器指令恢复它的值就行。这就要看能不能摸透uniqueval了)。</li></ul><p>所以，说了这么多，还是尽量选第一个吧。毕竟我们的目标比较简单，目测注入代码也比较少。</p><blockquote><p>把这一坨东西丢进我“30行的cpp程序”中，去掉没用的信息(没错就是这么懒)<br><code>0x55683588 &lt;_reserved+1037704&gt;:    0x00    0x00    0x00    0x00    0x8d    0xe4    0xe2    0xf7</code><br><code>0x55683590 &lt;_reserved+1037712&gt;:    0x00    0x00    0x00    0x00    0xa8    0x8d    0x04    0x08</code><br><code>0x55683598 &lt;_reserved+1037720&gt;:    0x1f    0x6b    0x00    0x00    0xfc    0x1d    0xfb    0xf7</code><br><code>0x556835a0 &lt;_reserved+1037728&gt;:    0xe0    0x35    0x68    0x55    0xee    0x42    0xef    0xf7</code><br><code>0x556835a8 &lt;_reserved+1037736&gt;:    0x60    0x1d    0xfb    0xf7    0x7e    0xa5    0x04    0x08</code><br><code>0x556835b0 &lt;_reserved+1037744&gt;:    0xe0    0x35    0x68    0x55    0xbe    0x8d    0x04    0x08</code><br>得到<br><code>00 00 00 00 8d e4 e2 f7</code><br><code>00 00 00 00 a8 8d 04 08</code><br><code>1f 6b 00 00 fc 1d fb f7</code><br><code>e0 35 68 55 ee 42 ef f7</code><br><code>60 1d fb f7 7e a5 04 08</code><br><code>e0 35 68 55 be 8d 04 08</code><br>将最后一行修改为”e0 35 68 55 <strong>88 35 68 55</strong>“，最后转成字符输出到文件，执行程序时重定向一下(因为有些字符是键盘上没有的)，就可以跳转到指定位置啦。<br>(在正常情况下这段字符不应含有0x00，因为一般的gets在判断到有0x00对应的字符时，应该是会终止输入的。这里它没有这个限制)</p></blockquote><p>接下来就要写我们想执行的机器代码了，有些人一上来就拿起本IA32机器指令手册一条一条对照，想想就很激动。<br>我开始也是这么想的，结果发现完全可以：手工写汇编code.s + gcc -c code.s + objdump -d code.o，我倒。</p><p>手写汇编代码，主要包含的要点：</p><ul><li>修改返回值是主要目的：<br><strong>movl $0x1005b2b7,%eax</strong></li><li><p>模拟函数调用：<br><strong>pushl $0x8048dbe</strong><br><strong>pushl %ebp</strong><br><strong>movl %esp,%ebp</strong><br><strong>subl $0x38,%esp</strong><br>…<br>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br>在模拟之前，首先要理解函数的调用过程：</p><ol><li><code>call，它的动作是push-and-jump(返回地址压栈，PC跳转);</code></li><li><code>push %ebp和mov %esp,%ebp(框架和栈指针合并);</code></li><li><code>sub %esp(为该函数分配栈空间，以便存放局部变量);</code></li></ol><p>由于我们第一步是通过hack了ret来实现的jump，所以并没有完全地按照call的动作，为了完全模拟，需要地址压栈，因此就不难理解第一行的<br><strong>pushl $0x8048dbe</strong>  (test中调用getbuf的下一行的地址)。</p></li><li>把控制权交回给test：<br><strong>leave</strong><br><strong>ret</strong><br>和getbuf函数的结束操作一样就行了:) 这里就顺便复习下leave和ret吧：<ol><li><code>leave是mov %ebp,%esp和pop %ebp(合并框架和栈指针，ebp回退到上一级函数状态)</code></li><li><code>ret是pop-and-jump(返回地址出栈，PC跳转)</code></li></ol></li></ul><p>最后的机器代码长这样：<br><img src="/2017/12/04/stack-overflow/machineCode.png" width="100%" height="100%"><br>从字符输入的起始位置替换：</p><pre><code>68 be 8d 04 08 55 89 e583 ec 38 b8 b7 b2 05 10c9 c3 00 00 fc 1d fb f7e0 35 68 55 ee 42 ef f760 1d fb f7 7e a5 04 08e0 35 68 55 88 35 68 55</code></pre><p>将这段机器指令用./hex2raw转换存到string.txt,<br><code>$ ./bufbomb -u bovik &lt; string.txt</code><br><img src="/2017/12/04/stack-overflow/finish1.png" width="100%" height="100%"></p><p>大功告成。</p><p><br><br><br><br><br><br><br><br><br></p><p>但是，还没有结束。<br>我们刚刚完成的是对一个“每次运行都使用相同栈地址”的演示程序的攻击。然鹅，在实际上，绝大多数的程序都会使用ASLR(address-space layout randomization)来作为保护。ASLR中的技术之一：栈随机化(stack randomization)能够有效防止栈溢出攻击。其主要表现为：在不同的时间运行同一段代码，里面使用到的栈地址都很可能不同。这可以通过”每次在程序执行前，在栈上分配一段随机大小的空间”来实现。</p><p>这样对于攻击者来说，在覆盖返回地址的时候不得不思考一个问题：-跳转到哪？-当然是能够执行我给它的机器指令的地方啊。-就是哪个地方？ -好像还真不好说，每次都不一样。</p><p>一般来说，考虑到程序的空间使用效率，栈随机化分配的空间不会太大。这时，就可以祭出nop-sled了：对于栈随机化程度有限，没有缓冲边界检查的程序，非常好用。那nop-sled到底该怎么用呢？在动手之前，我也有这个疑惑。<br>以下是我实际操作过程中的一些思考：<br>矛盾点在于，<strong>跳转的地址没办法确定为一个值(由于栈随机化)，而输入的攻击字符串却要求是固定的一个值。</strong>覆盖返回地址作为栈溢出攻击的第一步，如果不确定这个值就没法执行注入代码，汇编写得再牛也白搭。</p><p>尝试多次执行同一个程序的同一个函数，可以发现栈指针和框架指针的地址都在一定的范围内波动，如下图所示：<br><img src="/2017/12/04/stack-overflow/stack-randomization.png" width="50%" height="50%"><br>可以看到存放数据的buffer的地址也在一定范围内波动。</p><p>就是说<strong>跳转的地址要选一个定值，并且无论这个值处于栈结构的哪个位置，最终都能够执行注入的机器指令。</strong></p><p>这就容易想到该怎么用nop-sled了：把注入代码存放在buffer的末端，只要找到一个共用地址，并用nop作为背景填充(保证共用地址和注入代码地址之间都是nop)，程序跳转到共用地址后开始执行nop，滑落到注入代码部分，攻击就能够实现。如下图所示：<br><img src="/2017/12/04/stack-overflow/nop-sled.png" width="50%" height="50%"><br>当然这个共用地址也可以划到buffer外面去，不过这样会腐蚀更多的内容，恢复的难度也会相应增加。</p><p>下面简单提一提破坏恢复难度。显然，覆盖返回地址，同时也意味着腐蚀了返回地址之前的信息，再次搬出前面的图：<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></p><ul><li>saved %ebp被覆盖：这导致上一级框架指针位置信息丢失。如果不考虑这一点，必然导致栈结构腐蚀，很可能导致段错误。</li><li>saved %ebx或其他callee-saved的寄存器保存的值被覆盖：如果说上一级%ebp的信息还能通过%esp计算找回来，这种类型的信息一旦丢失，几乎无从找回，或者说找回的难度直接受”原程序计算出该值的方式“影响。要想恢复，汇编功底需要极其深厚。</li></ul><p>最后，总结一下栈溢出攻击的步骤：</p><ol><li>试探：看看有没有边界检查</li><li>确定覆盖点：在汇编中找到原返回地址，并和正常执行时的内存比对</li><li>分析注入代码存放位置：考虑注入代码长度、结构腐蚀的可恢复性</li><li>手写汇编代码：爱干啥干啥，如果要做到不留痕迹，恢复破坏的数据</li><li>汇编为机器指令，生成字符串：十六进制数字转字符</li><li>fire！</li></ol><p>最后的最后，要想避免自己的程序被别人用这种方式攻击，最简单的方法当然就是做好边界检查，让你写入32个字符就只能写入32个，多半个都不行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/home.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配套网站&lt;/a&gt;和里面的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/labs.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验室&lt;/a&gt;献上。。没有膝盖了，就点个赞吧。&lt;br&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="栈溢出" scheme="tangenta.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++读文件操作暗礁</title>
    <link href="tangenta.github.io/2017/10/26/fstream-trap/"/>
    <id>tangenta.github.io/2017/10/26/fstream-trap/</id>
    <published>2017-10-26T13:16:00.000Z</published>
    <updated>2018-01-13T10:51:37.062Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，先出一道题：<br>给定一个<strong>行数=3</strong>的文本文件，如何把每行的内容读出来存到std::vector<string>里面？<br><a id="more"></a></string></p><p>如果你的答案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">fstream <span class="title">in</span><span class="params">(<span class="string">"text"</span>)</span></span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line"><span class="built_in">string</span> buf;</div><div class="line"><span class="keyword">while</span>(in) &#123;</div><div class="line">  getline(in, buf);</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么我掐指一算：<br>你最近是不是感觉到你写的文件读写程序，行为有点怪异？<br>是不是忍不住发出惊叹“明明读完了啊，怎么多一行“？<br>是不是把fstream里面有关good/eof/fail/bad的文档全看了一遍，还是找不到问题在哪？<br>是不是才爬个5楼，就觉得胸闷气短…<br>咳，回到正题：如果在最后加一句</p><pre><code>cout&lt;&lt;v.size()&lt;&lt;&quot;\n&quot;;</code></pre><p>发现结果是4。分析一下原因：在in&gt;&gt;buf读取文件最后一行的时候，状态为goodbit，v.push_back正常读入最后一行;再次判断循环条件，由于goodbit，进入循环;这时in&gt;&gt;tmp就开始出问题了，它读到了文件结束符eof。然而我们的buf可不管，读不到东西也push_back，这就造成size比行数大1的结果。<br>总结起来一句话就是：<strong>“从文件读取到缓冲”和”从缓冲输入到容器”之间没有空隙，即无条件连接。</strong><br>显然，while的条件判断起作用的时机晚了。一个解决方案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;<span class="comment">//solution1</span></div><div class="line">  getline(in, buf);</div><div class="line">  <span class="keyword">if</span> (!in) <span class="keyword">break</span>;</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其等价于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(getline(in, buf)) &#123;<span class="comment">//solution2</span></div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二个解决方案也是C++中的惯用法(idiom)，更为简洁、美观。</p><pre><code>return;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，先出一道题：&lt;br&gt;给定一个&lt;strong&gt;行数=3&lt;/strong&gt;的文本文件，如何把每行的内容读出来存到std::vector&lt;string&gt;里面？&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>邂逅异或链表</title>
    <link href="tangenta.github.io/2017/10/22/xorLinkedList/"/>
    <id>tangenta.github.io/2017/10/22/xorLinkedList/</id>
    <published>2017-10-22T13:39:00.000Z</published>
    <updated>2018-01-13T10:51:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。</p><a id="more"></a><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>异或链表的原理是，表中的每个节点跟单链表一样，都有俩区域: 数据域和指针域。这个指针域就厉害了，存的不是别人，而是它前后节点地址的异或。得益于异或运算的性质，任何时候只需要知道链表中相邻的两个节点地址，就可以访问其中的每一个节点。以前只听过异或运算能用来实现inplace swap(不需要额外的空间就可以交换两个变量)，没想到还能应用到链表中。</p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>看起来很简单嘛，内嵌一个节点类，复制控制函数压死，再上容器四大护法增删改查，一切都很顺利……嗯？这段怎么这么deja vu？定睛一看，这几段都有遍历操作，而每次遍历都用到两个节点指针，一前一后一个while，内部再一个判断一个break。想起scott meyers教导我们，代码复制不可取。今天复制一段代码，明天就会复制一个文件，后天……跑题了，总之作为一个有理想的青年，代码复制要不得。想到这里，我这暴脾气就上来了，一顿操作从删掉重写到发朋友圈，丝毫不拖泥带水，思考时被我拔掉的头发也不算特别多。这个是效果：</p><p>修改前:<br><img src="/2017/10/22/xorLinkedList/2017-10-22-1.png" width="50%" height="50%"></p><p>修改后：<br><img src="/2017/10/22/xorLinkedList/2017-10-22-2.png" width="50%" height="50%"></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-3.png" width="100%" height="100%"></p><p>将判断条件、迭代调整、返回值做成函数调用形式，达到用模板参数传递”功能“(函数指针、函数对象或lambda表达式)的目的。简单说就是从外部把功能嵌入函数体中。</p><p>一个traverse函数打天下 =_=</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>敲定最后一个lambda表达式，好不容易松了口气，正欣赏着”成果”，不知道《C++ template》的哪一个混蛋作者在我脑子里喊了句”code bloat”。</p><p>。。。</p><p>。。。</p><p>我、lambda表达式们大眼瞪小眼，这时我才发现一个个的lambda(s?)，每个类型都不相同，这意味着几乎每次使用到traverse()都要实例化，我仿佛已经看到了目标文件的臃肿。再一细看，还把traverse写成了public。典型滥用模板的例子，哎。</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>我不甘心啊！伴随着更多头发的飘落，”遍历“这个词终于让我联想到了”迭代器“。是啊，为什么不搞一个迭代器呢？<br>for(List<t>::iterator i = v.begin(); i != v.end(); ++i) {…}，<br>多么优雅。但是迭代器内部的数据一般只有一个指针，而异或链表的遍历必须由两个指针贴着走。那一个迭代器包含两个指针行不行呢？开始尝试：</t></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-4.png" width="100%" height="100%"><br>解引用操作和指针操作都取ptr2，{ptr1 = 0; ptr2 = head}对应begin，{ptr1 = tail, ptr2 = 0}对应end，没毛病。</p><p>(中间踩了点小坑，这里省略一万字，”explicit你都干了些什么”、”包含编译模型之凝视”、”const成员函数之谜”、”多余&amp;引发的运行时血案”之类的不再细叙)</p><p>最终效果如下：<br>(这是获得第pos-1个节点和第pos个节点指针的具体实现)<br><img src="/2017/10/22/xorLinkedList/2017-10-22-5.png" width="100%" height="100%"><br>很明显，无论是易读性、可维护性都提高了不少。</p><p><a href="https://gitee.com/tangenta/XorList.git" target="_blank" rel="external">XorList源码</a></p><p>虽然简陋版迭代器是写出来了，但不知道它和stl算法的结合情况如何。哪天出乱子了我再收拾它去。</p><pre><code>return (待续||不续);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。&lt;/p&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
      <category term="stl" scheme="tangenta.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="tangenta.github.io/2017/09/28/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>tangenta.github.io/2017/09/28/git学习笔记/</id>
    <published>2017-09-28T07:58:00.000Z</published>
    <updated>2018-01-13T10:50:30.024Z</updated>
    
    <content type="html"><![CDATA[<p>用作记录，方便查阅<br><a id="more"></a></p><h2 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git init</td><td>在当前目录初始化仓库</td></tr></tbody></table><h2 id="提交-上传文件"><a href="#提交-上传文件" class="headerlink" title="提交/上传文件"></a>提交/上传文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git add fileName</td><td>将工作区文件添加到暂存区</td></tr><tr><td> $ git commit -m “some comment”</td><td>将暂存区文件添加到版本库</td></tr></tbody></table><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git rm fileName</td><td>删掉暂存区的文件</td></tr></tbody></table><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git status</td><td>显示仓库当前状态</td></tr><tr><td> $ git diff fileName</td><td>显示工作区和版本库的差异</td></tr><tr><td> $ git log [–pretty=oneline] [–graph] [–abbrev-commit]</td><td>显示版本库内的commit历史记录 [以单行的形式显示][显示分支图]</td></tr><tr><td> $ git reflog</td><td>显示版本变更的历史命令</td></tr><tr><td> $ git branch</td><td>查看当前所在的分支</td></tr><tr><td> $ git stash list</td><td>查看被储存的工作区列表</td></tr><tr><td> $ git remote -v</td><td>查看远程库的[详细]信息</td></tr><tr><td> $ git tag</td><td>查看所有标签</td></tr><tr><td> $ git show <tagname></tagname></td><td>查看某一个标签的信息</td></tr></tbody></table><h2 id="版本设置"><a href="#版本设置" class="headerlink" title="版本设置"></a>版本设置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git reset –hard HEAD^</td><td>HEAD为当前版本，每一个”^”代表上一个版本。HEAD~n代表上n个版本</td></tr><tr><td> $ git reset –hard commitId</td><td>将当前版本设置到版本号为“commitId”的版本</td></tr></tbody></table><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout – fileName</td><td>使工作区文件撤销到(暂存区或版本库)的状态</td></tr><tr><td> $ git reset HEAD fileName</td><td>使暂存区的文件撤销到版本库的状态</td></tr></tbody></table><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ ssh-keygen -t rsa -C “email@example.com”</td><td>获取ssh key</td></tr><tr><td> $ git remote add origin git@serverName:path/repoName.git</td><td>关联远程库</td></tr><tr><td> $ git remote rm origin</td><td>删除origin远程库</td></tr><tr><td> $ git push -u origin master</td><td>第一次推送master分支的所有内容</td></tr><tr><td> $ git push origin master</td><td>推送最新修改</td></tr><tr><td> $ git clone git@serverName:path/repoName.git</td><td>克隆远程仓库到本地</td></tr><tr><td> $ git push origin master</td><td>把本地的master分支推送到远程origin分支上</td></tr></tbody></table><h2 id="创建-合并-删除分支"><a href="#创建-合并-删除分支" class="headerlink" title="创建/合并/删除分支"></a>创建/合并/删除分支</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout -b dev origin/dev</td><td>创建一个dev分支，并关联远程的orgin/dev分支</td></tr><tr><td> $ git branch –set-upstream dev origin/dev</td><td>设置本地dev于远程仓库origin/dev关联</td></tr><tr><td> $ git pull</td><td>将本地文件与远程仓库同步</td></tr><tr><td> $ git checkout -b dev</td><td>创建并切换到分支dev</td></tr><tr><td> $ git branch dev</td><td>创建分支dev</td></tr><tr><td> $ git checkout dev</td><td>切换到分支dev</td></tr><tr><td> $ git merge dev</td><td>把分支dev合并到当前分支</td></tr><tr><td> $ git branch -d dev</td><td>删除已被合并的分支dev</td></tr><tr><td> $ git branch -D dev</td><td>强制删除未合并的分支dev</td></tr><tr><td> $ git merge –no-ff -m “some comments” dev</td><td>以创建一个commit的方式合并dev分支</td></tr></tbody></table><h2 id="工作区临时储存-恢复"><a href="#工作区临时储存-恢复" class="headerlink" title="工作区临时储存/恢复"></a>工作区临时储存/恢复</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git stash</td><td>储存当前工作区状态，并清空</td></tr><tr><td> $ git stash apply [stash@{n}]</td><td>恢复上一个被储存的工作区 [第n个储存的工作区]</td></tr><tr><td> $ git stash drop</td><td>删除stash list</td></tr><tr><td> $ git stash pop</td><td>恢复工作区，并删除stash list</td></tr></tbody></table><h2 id="标签创建-删除"><a href="#标签创建-删除" class="headerlink" title="标签创建/删除"></a>标签创建/删除</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git tag v1.0 [commit Id]</td><td>为当前最新的提交创建名为v1.0的标签 [对给定提交id创建]</td></tr><tr><td> $ git tag -a v0.1 -m “some comments” commitId</td><td>-a指定名字，-m指定说明文字</td></tr><tr><td> $ git tag -d v0.1</td><td>删除名为v0.1的标签</td></tr><tr><td> $ git push origin <tagname></tagname></td><td>将tagName标签推送到远程</td></tr><tr><td> $ git push origin –tags</td><td>将所有未推送的标签推送到远程</td></tr><tr><td> $ git push origin :refs/tags/v0.9</td><td>删除远程名为v0.9的标签</td></tr></tbody></table><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git config –global color.ui true</td><td>显示颜色</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用作记录，方便查阅&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
      <category term="git" scheme="tangenta.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GDB常用命令汇总</title>
    <link href="tangenta.github.io/2017/09/27/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>tangenta.github.io/2017/09/27/GDB常用命令汇总/</id>
    <published>2017-09-27T12:36:00.000Z</published>
    <updated>2018-01-13T10:50:06.856Z</updated>
    
    <content type="html"><![CDATA[<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><title>GDB常用命令汇总</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="generator" content="Org-mode"><style type="text/css"> <!--/*--><![CDATA[/*><!--*/  .title  { text-align: center; }  .todo   { font-family: monospace; color: red; }  .done   { color: green; }  .tag    { background-color: #eee; font-family: monospace;            padding: 2px; font-size: 80%; font-weight: normal; }  .timestamp { color: #bebebe; }  .timestamp-kwd { color: #5f9ea0; }  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }  .center { margin-left: auto; margin-right: auto; text-align: center; }  .underline { text-decoration: underline; }  #postamble p, #preamble p { font-size: 90%; margin: .2em; }  p.verse { margin-left: 3%; }  pre {    border: 1px solid #ccc;    box-shadow: 3px 3px 3px #eee;    padding: 8pt;    font-family: monospace;    overflow: auto;    margin: 1.2em;  }  pre.src {    position: relative;    overflow: visible;    padding-top: 1.2em;  }  pre.src:before {    display: none;    position: absolute;    background-color: white;    top: -10px;    right: 10px;    padding: 3px;    border: 1px solid black;  }  pre.src:hover:before { display: inline;}  pre.src-sh:before    { content: 'sh'; }  pre.src-bash:before  { content: 'sh'; }  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }  pre.src-R:before     { content: 'R'; }  pre.src-perl:before  { content: 'Perl'; }  pre.src-java:before  { content: 'Java'; }  pre.src-sql:before   { content: 'SQL'; }  table { border-collapse:collapse; }  caption.t-above { caption-side: top; }  caption.t-bottom { caption-side: bottom; }  td, th { vertical-align:top;  }  th.right  { text-align: center;  }  th.left   { text-align: center;   }  th.center { text-align: center; }  td.right  { text-align: right;  }  td.left   { text-align: left;   }  td.center { text-align: center; }  dt { font-weight: bold; }  .footpara:nth-child(2) { display: inline; }  .footpara { display: block; }  .footdef  { margin-bottom: 1em; }  .figure { padding: 1em; }  .figure p { text-align: center; }  .inlinetask {    padding: 10px;    border: 2px solid gray;    margin: 10px;    background: #ffffcc;  }  #org-div-home-and-up   { text-align: right; font-size: 70%; white-space: nowrap; }  textarea { overflow-x: auto; }  .linenr { font-size: smaller }  .code-highlighted { background-color: #ffff00; }  .org-info-js_info-navigation { border-style: none; }  #org-info-js_console-label    { font-size: 10px; font-weight: bold; white-space: nowrap; }  .org-info-js_search-highlight    { background-color: #ffff00; color: #000000; font-weight: bold; }  /*]]>*/--></style><script type="text/javascript">/*@licstart  The following is the entire license notice for theJavaScript code in this tag.Copyright (C) 2012-2013 Free Software Foundation, Inc.The JavaScript code in this tag is free software: you canredistribute it and/or modify it under the terms of the GNUGeneral Public License (GNU GPL) as published by the Free SoftwareFoundation, either version 3 of the License, or (at your option)any later version.  The code is distributed WITHOUT ANY WARRANTY;without even the implied warranty of MERCHANTABILITY or FITNESSFOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.As additional permission under GNU GPL version 3 section 7, youmay distribute non-source (e.g., minimized or compacted) forms ofthat code without the copy of the GNU GPL normally required bysection 4, provided you include this license notice and a URLthrough which recipients can access the Corresponding Source.@licend  The above is the entire license noticefor the JavaScript code in this tag.*/<!--/*--><![CDATA[/*><!--*/ function CodeHighlightOn(elem, id) {   var target = document.getElementById(id);   if(null != target) {     elem.cacheClassElem = elem.className;     elem.cacheClassTarget = target.className;     target.className = "code-highlighted";     elem.className   = "code-highlighted";   } } function CodeHighlightOff(elem, id) {   var target = document.getElementById(id);   if(elem.cacheClassElem)     elem.className = elem.cacheClassElem;   if(elem.cacheClassTarget)     target.className = elem.cacheClassTarget; }/*]]>*///--></script></head><body><p>用作记录，方便查阅</p><a id="more"></a><div id="content"><div id="table-of-contents"><h1>Table of Contents</h1><div id="text-table-of-contents"><ul><li><a href="#sec-1">1. Starting</a></li><li><a href="#sec-2">2. Running and stopping</a></li><li><a href="#sec-3">3. Breakpoints</a></li><li><a href="#sec-4">4. Execution</a></li><li><a href="#sec-5">5. Examining code</a></li><li><a href="#sec-6">6. Examining data</a></li><li><a href="#sec-7">7. Useful information</a></li></ul></div></div><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">Command</td><td class="left">Effect</td></tr></tbody></table><div id="outline-container-sec-1" class="outline-1"><h1 id="sec-1"><span class="section-number-1">1</span> Starting</h1><div class="outline-text-1" id="text-1"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">gdb</td><td class="left">&#xa0;</td></tr><tr><td class="left">gdb &lt;file&gt;</td><td class="left">&#xa0;</td></tr></tbody></table></div></div><div id="outline-container-sec-2" class="outline-1"><h1 id="sec-2"><span class="section-number-1">2</span> Running and stopping</h1><div class="outline-text-1" id="text-2"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">run</td><td class="left">Run program</td></tr><tr><td class="left">run 1 2 3</td><td class="left">Run program with command-line arguments 1 2 3</td></tr><tr><td class="left">kill</td><td class="left">Stop the program</td></tr><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">Ctrl-d</td><td class="left">Exit gdb</td></tr></tbody></table><p>Note: Ctrl-C does not exit from gdb, but halts the currentgdb command</p></div></div><div id="outline-container-sec-3" class="outline-1"><h1 id="sec-3"><span class="section-number-1">3</span> Breakpoints</h1><div class="outline-text-1" id="text-3"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">break sum</td><td class="left">Set breakpoint at the entry to function sum</td></tr><tr><td class="left">break *0x80483c3</td><td class="left">Set breakpoint at address 0x80483c3</td></tr><tr><td class="left">delete 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">disable 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">enable 1</td><td class="left">Enable breakpoint 1</td></tr><tr><td class="left">delete</td><td class="left">Delete all breakpoints</td></tr><tr><td class="left">clear sum</td><td class="left">clear sum</td></tr></tbody></table></div></div><div id="outline-container-sec-4" class="outline-1"><h1 id="sec-4"><span class="section-number-1">4</span> Execution</h1><div class="outline-text-1" id="text-4"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">stepi</td><td class="left">Execute one instruction</td></tr><tr><td class="left">stepi 4</td><td class="left">Execute four instructions</td></tr><tr><td class="left">nexti</td><td class="left">Like stepi, but proceed through function calls without stopping</td></tr><tr><td class="left">step</td><td class="left">Execute one C statement</td></tr><tr><td class="left">continue</td><td class="left">Resume execution until the next breakpoint</td></tr><tr><td class="left">until 3</td><td class="left">Continue executing until program hits breakpoint 3</td></tr><tr><td class="left">finish</td><td class="left">Resume execution until current function returns</td></tr><tr><td class="left">call sum(1,2)</td><td class="left">Call sum(1,2) and print return value</td></tr></tbody></table></div></div><div id="outline-container-sec-5" class="outline-1"><h1 id="sec-5"><span class="section-number-1">5</span> Examining code</h1><div class="outline-text-1" id="text-5"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">disas</td><td class="left">Disassemble current function</td></tr><tr><td class="left">disas sum</td><td class="left">Disassemble function sum</td></tr><tr><td class="left">disas 0x80483b7</td><td class="left">Disassemble function around 0x80483b7</td></tr><tr><td class="left">disas 0x80483b7 0x80483c7</td><td class="left">Disassemble code within specified address range</td></tr><tr><td class="left">print /x $rip</td><td class="left">Print program counter in hex</td></tr><tr><td class="left">print /d $rip</td><td class="left">Print program counter in decimal</td></tr><tr><td class="left">print /t $rip</td><td class="left">Print program counter in binary</td></tr></tbody></table></div></div><div id="outline-container-sec-6" class="outline-1"><h1 id="sec-6"><span class="section-number-1">6</span> Examining data</h1><div class="outline-text-1" id="text-6"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print /d $rax</td><td class="left">Print contents of %rax in decimal</td></tr><tr><td class="left">print /x $rax</td><td class="left">Print contents of %rax in hex</td></tr><tr><td class="left">print /t $rax</td><td class="left">Print contents of %rax in binary</td></tr><tr><td class="left">print /d (int)$rax</td><td class="left">Print contents of %rax in decimal after sign-extending lower 32-bits.</td></tr></tbody></table><p>You need this to print 32-bit, negative numbers stored in the lower 32 bits of %rax.For example, if the lower 32-bits of %rax store 0xffffffff, you will see: </p><pre class="example">(gdb) print $rax$1 = 4294967295(gdb) print (int)$rax$2 = -1</pre><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print 0x100</td><td class="left">Print decimal representation of 0x100</td></tr><tr><td class="left">print /x 555</td><td class="left">Print hex representation of 555</td></tr><tr><td class="left">print /x ($rsp+8)</td><td class="left">Print (contents of %rsp) + 8 in hex</td></tr><tr><td class="left">print *(int *) 0xbffff890</td><td class="left">Print integer at address 0xbffff890</td></tr><tr><td class="left">print *(int *) ($rsp+8)</td><td class="left">Print integer at address %rsp + 8</td></tr><tr><td class="left">print (char *) 0xbfff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/w   0xbffff890</td><td class="left">Examine (4-byte) word starting at address 0xbffff890</td></tr><tr><td class="left">x/w   $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp</td></tr><tr><td class="left">x/wd  $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/2w  $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp</td></tr><tr><td class="left">x/2wd $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/g   $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp.</td></tr><tr><td class="left">x/gd  $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/a   $rsp</td><td class="left">Examine address in $rsp. Print as offset from previous global symbol.</td></tr><tr><td class="left">x/s   0xbffff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/20b sum</td><td class="left">Examine first 20 opcode bytes of function sum</td></tr><tr><td class="left">x/10i sum</td><td class="left">Examine first 10 instructions of function sum</td></tr></tbody></table><p>(Note: the format string for the `x' command has the general form x/[NUM][SIZE][FORMAT] where</p><pre class="example">NUM  = number of objects to display.SIZE = size of each object (b=byte, h=half-word, w=word, g=giant (quad-word))FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)</pre><p>  If you don't specify SIZE or FORMAT, either a default value, or the last  value you specified in a previous `print' or `x' command is used.)</p></div></div><div id="outline-container-sec-7" class="outline-1"><h1 id="sec-7"><span class="section-number-1">7</span> Useful information</h1><div class="outline-text-1" id="text-7"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">backtrace</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">where</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">info program</td><td class="left">Print current status of the program)</td></tr><tr><td class="left">info functions</td><td class="left">Print functions in program</td></tr><tr><td class="left">info stack</td><td class="left">Print backtrace of the stack)</td></tr><tr><td class="left">info frame</td><td class="left">Print information about the current stack frame</td></tr><tr><td class="left">info registers</td><td class="left">Print registers and their contents</td></tr><tr><td class="left">info breakpoints</td><td class="left">Print status of user-settable breakpoints</td></tr><tr><td class="left">display /FMT EXPR</td><td class="left">Print expression EXPR using format FMT every time GDB stops</td></tr><tr><td class="left">undisplay</td><td class="left">Turn off display mode</td></tr><tr><td class="left">help</td><td class="left">Get information about gdb</td></tr></tbody></table></div></div></div><div id="postamble" class="status"><p class="creator"><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 24.5.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)</p><p class="validation"><a href="http://validator.w3.org/check?uri=referer" target="_blank" rel="external">Validate</a></p></div></body></html>]]></content>
    
    <summary type="html">
    
      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot; xml:lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;GDB常用命令汇总&lt;/title&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;meta name=&quot;generator&quot; content=&quot;Org-mode&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
 &lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: &#39;sh&#39;; }
  pre.src-bash:before  { content: &#39;sh&#39;; }
  pre.src-emacs-lisp:before { content: &#39;Emacs Lisp&#39;; }
  pre.src-R:before     { content: &#39;R&#39;; }
  pre.src-perl:before  { content: &#39;Perl&#39;; }
  pre.src-java:before  { content: &#39;Java&#39;; }
  pre.src-sql:before   { content: &#39;SQL&#39;; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]&gt;*/--&gt;
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
&lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = &quot;code-highlighted&quot;;
     elem.className   = &quot;code-highlighted&quot;;
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]&gt;*///--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;用作记录，方便查阅&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令实例 (长期更新)</title>
    <link href="tangenta.github.io/2017/09/24/Linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>tangenta.github.io/2017/09/24/Linux命令实例（长期更新）/</id>
    <published>2017-09-24T13:10:00.000Z</published>
    <updated>2018-01-13T10:49:29.383Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用linux命令<br><a id="more"></a></p><h2 id="文本文件在windows和linux之间的相互转换"><a href="#文本文件在windows和linux之间的相互转换" class="headerlink" title="文本文件在windows和linux之间的相互转换"></a>文本文件在windows和linux之间的相互转换</h2><p>差异：windows下的文本文件的编码方式默认采用的是GBK，而linux默认采用utf-8，因此同一文件在两种操作系统下可能会出现中文乱码的现象。另外，windows文件的换行符为’/r/n’，而linux文件则为’/n’，也会导致一系列奇怪问题的产生。</p><p>windows -&gt; linux: 多出来的 <strong>/r</strong> 文件换行符在vi下以 <strong>^M</strong> 的形式呈现。</p><ul><li><p>移除 <strong>^M</strong>: <code>sed -i &#39;s/^M//g&#39; fileName</code></p><blockquote><p><strong>-i</strong>  : 直接修改文件内容，不输出<br><strong>s</strong>  : 取代<br><strong>^M</strong> : 通过ctrl+v ctrl+m 输入<br><strong>g</strong>  : 应用于全局<br>‘s/匹配文本/替换文本/g’</p></blockquote></li><li><p>添加<strong>^M</strong>: <code>sed -i &#39;s/$/^M/g&#39; fileName</code></p><blockquote><p><strong>$</strong>: 匹配行末</p></blockquote></li><li><p>转换编码方式: <code>iconv -f gbk -t utf8 fileName &gt; newFileName</code></p><blockquote><p><strong>-f</strong>: from<br> <strong>-t</strong>: to</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用linux命令&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
