<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road to PI/2</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="tangenta.github.io/"/>
  <updated>2018-10-23T13:45:13.766Z</updated>
  <id>tangenta.github.io/</id>
  
  <author>
    <name>tangenta</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解scala函数型变</title>
    <link href="tangenta.github.io/2018/10/23/%E7%90%86%E8%A7%A3scala%E5%87%BD%E6%95%B0%E5%9E%8B%E5%8F%98/"/>
    <id>tangenta.github.io/2018/10/23/理解scala函数型变/</id>
    <published>2018-10-23T12:20:00.000Z</published>
    <updated>2018-10-23T13:45:13.766Z</updated>
    
    <content type="html"><![CDATA[<p>忍不住记录一下入坑以来的心动时刻。</p><a id="more"></a><h2 id="函数的地位"><a href="#函数的地位" class="headerlink" title="函数的地位"></a>函数的地位</h2><p>众所周知，函数在scala中是一等公民（first citizen），函数值（function value）的引入使得函数和对象一样，它们在运行时实例化，能够作为实参被花式传递，这样高阶函数们就像自带可定制化插件的机器一样，拥有了高度的灵活性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"></div><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span></span>(x: <span class="type">Int</span>) = x + <span class="number">1</span></div><div class="line">plusOne: (x: <span class="type">Int</span>)<span class="type">Int</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> plusOne2 = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></div><div class="line">plusOne2: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; plusOne(<span class="number">2</span>)</div><div class="line">res3: <span class="type">Int</span> = <span class="number">3</span></div><div class="line"></div><div class="line">scala&gt; plusOne2(<span class="number">2</span>)</div><div class="line">res4: <span class="type">Int</span> = <span class="number">3</span></div><div class="line"></div><div class="line">scala&gt; println(list map plusOne)</div><div class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">scala&gt; println(list map plusOne2)</div><div class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure><p>上面的plusOne2就是一个函数值，它在使用上和真正的函数——plusOne几乎没有区别，但从定义时REPL的反馈中可以看出，这是个类型为Function1的对象，FunctionN实际上是scala包中的特质，其中N代表参数的个数（至于为什么它能够像方法一样被调用，是因为它的类实现了apply方法）。</p><h2 id="函数对象类型"><a href="#函数对象类型" class="headerlink" title="函数对象类型"></a>函数对象类型</h2><p>这时如果我们小手一抖，不小心打开了IntelliJ，一不留神输入了Function1,大意之下按住Ctrl+点击鼠标左键——复操作数步，豁然开朗：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@specialized(scala.<span class="type">Int</span>, scala.<span class="type">Long</span>, scala.<span class="type">Float</span>, scala.<span class="type">Double</span>) -<span class="type">T1</span>, @specialized(scala.<span class="type">Unit</span>, scala.<span class="type">Boolean</span>, scala.<span class="type">Int</span>, scala.<span class="type">Float</span>, scala.<span class="type">Long</span>, scala.<span class="type">Double</span>) +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</div><div class="line">  <span class="comment">/** Apply the body of this function to the argument.</span></div><div class="line"><span class="comment">   *  @return   the result of function application.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">T1</span>): <span class="type">R</span></div><div class="line">  <span class="comment">// 省略部分方法定义</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>() = <span class="string">"&lt;function1&gt;"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这是Function1特质的定义。把注解（annotation）扔掉不看，焦点放在两个类型参数T1和R，它们分别对应函数的参数类型和返回值类型。除此之外，T1和R前面的符号表明了该函数参数是可型变的。</p><p>那，什么是型变呢？</p><h2 id="型变-协变-逆变"><a href="#型变-协变-逆变" class="headerlink" title="型变 = 协变 | 逆变"></a>型变 = 协变 | 逆变</h2><p>《Programming in Scala》一书中对型变的描述大致如下:</p><blockquote><p>对于某个类C[T]（C可以是类或特质，T为类型参数），考虑这样一个问题：假如S为T的子类型，C[S]是否应该为C[T]的<strong>子类型</strong>。如果是，那就可以说C在T上是<strong>协变</strong>（covariant）的，用C[+T]表示。</p><p>相反，假如S为T的子类型，C[s]应该为C[T]的<strong>超类型</strong>，那就可以说C在T上是<strong>逆变</strong>（contravariant）的，用C[-T]表示。</p></blockquote><p>从直觉上看，容器上的协变是较为容易理解的。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Animal</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">language</span></span>:<span class="type">String</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">language</span></span>: <span class="string">"Meow"</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">language</span></span>: <span class="string">"Wang"</span>&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAllLanguage</span></span>(list: <span class="type">List</span>[<span class="type">Animal</span>]) = list foreach println</div><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>[<span class="type">Cat</span>](<span class="keyword">new</span> <span class="type">Cat</span>, <span class="keyword">new</span> <span class="type">Cat</span>)</div><div class="line">printAllLanguage(list)<span class="comment">// 类型检查通过</span></div></pre></td></tr></table></figure></p><p>Animal特质派生出Cat，Dog类，并指定了抽象方法language。接下来有一个方法printAllLanguage接受List[Animal]作为参数，打印List中所有动物的语言。这时实例化一个列表List[Cat]并将其应用到（apply to）printAllLanguage时——由于List特质是协变的，Animal是Cat的超类型，因此List[Animal]是List[Cat]的超类型，故类型检查通过。</p><p>具有特殊功能的结构的逆变也勉强能够理解，例如OutputChannal[String]，其功能就是对外传输字符串。根据<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="external">里氏替换原则（The Liskov Substitution Principle）</a>，在需要OutputChannal[String]的地方传入一个OutputChannal[AnyRef]，问题不大，因此OutputChannal[-T]是合理的。</p><h2 id="函数对象类型的型变"><a href="#函数对象类型的型变" class="headerlink" title="函数对象类型的型变"></a>函数对象类型的型变</h2><p>介绍完型变，转回前面提到的函数对象类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T1</span>, +<span class="type">R</span>] </span>&#123;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">T1</span>): <span class="type">R</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>位于类型参数T1和R前面的符号的含义翻译过来就是：<strong>Function1的参数类型是逆变的，返回值类型是协变的</strong>。</p><p>如何理解？</p><p>首先我们要搞清楚，在什么情况下Function1[A, B]是Function1[C, D]的超类型。也就是说，ABCD之间满足什么条件时，在期望类型为Function1[A, B]对象的位置能够用Funciton1[C, D]代替。</p><p><img src="/images/scala-variance1.png" alt="upload successful"></p><p>型变的定义说，他们的关系应该是这样的：</p><p><img src="/images/scala-variance2.jpg.png" alt="upload successful"></p><p>也就是当A继承C，D继承B时，才有这样的函数对象类型关系。</p><p>且看《Programming in Scala》书中的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publication</span>(<span class="params">val title: <span class="type">String</span></span>)</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Book</span>(<span class="params">title: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Publication</span>(<span class="params">title</span>)</span></div><div class="line"><span class="class"><span class="title">object</span> <span class="title">Library</span> </span>&#123;</div><div class="line"><span class="keyword">val</span> books: <span class="type">Set</span>[<span class="type">Book</span>] =</div><div class="line"><span class="type">Set</span>(</div><div class="line"><span class="keyword">new</span> <span class="type">Book</span>(<span class="string">"Programming in Scala"</span>),</div><div class="line"><span class="keyword">new</span> <span class="type">Book</span>(<span class="string">"Walden"</span>)</div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printBookList</span></span>(info: <span class="type">Book</span> =&gt; <span class="type">AnyRef</span>) = &#123;</div><div class="line"><span class="keyword">for</span> (book &lt;- books) println(info(book))</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span></span>(p: <span class="type">Publication</span>): <span class="type">String</span> = p.title</div><div class="line"><span class="type">Library</span>.printBookList(getTitle)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里Library.printBookList方法期望接受一个函数，类型为</p><blockquote><p>(Book =&gt; AnyRef)</p></blockquote><p>而实际使用时传入的函数类型为</p><blockquote><p>(Publication =&gt; String)</p></blockquote><p>此外，Book继承自Publication，String继承自AnyRef。</p><p>接下来我们只看printBookList方法的定义。对于printBookList来说，它拥有的信息无非只有两个：一个是内部的books，一个是从参数中拿到的info函数。它要利用info函数，就必须为它提供一个值，而这样做带来的好处是，它能够使用这个info函数的返回结果。</p><p>于是我们有这样的关系：printBookList是info函数参数的<strong>提供者</strong>（提供了books对象），是info函数返回值的<strong>使用者</strong>（把结果拿来println）。</p><p>作为提供者，应当提供尽可能具体的类，这样有更多适配的基类; 作为使用者，则应当尽可能减少对该值的要求，增强通用性。如此一来，当一个“参数更抽象（即-要求比较少），返回值更具体（可能有着更多的方法，即便用不到）”的函数被传进来时，完全符合里氏替换原则。</p><p>所以说，<strong>Function1[Book, AnyRef]</strong>是<strong>Function1[Publication, String]</strong>的超类型，也可以被具有类似特征的Function1替换（适配）。</p><h2 id="猫论中functor的型变"><a href="#猫论中functor的型变" class="headerlink" title="猫论中functor的型变"></a>猫论中functor的型变</h2><p>本来这篇博客到这里就结束了，但是当我了解到逆变函子（contravariant functor）时，猛然发现猫论（category theory）中的型变和计算机科学所说的型变似乎有一些联系。</p><h3 id="协变函子和逆变函子"><a href="#协变函子和逆变函子" class="headerlink" title="协变函子和逆变函子"></a>协变函子和逆变函子</h3><p>先看协变函子：协变函子其实就是普通的functor，在哈斯凯尔（别名Haskell）中functor需要支持的操作如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></div><div class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; f a -&gt; f b</div></pre></td></tr></table></figure></p><p><img src="/images/scala-variance3.png" alt="upload successful"></p><p>其中f是某种<strong>结构</strong>，“f x”可以理解为，它接受一个类型参数x作为内部数据类型。fmap的功能为：接受一个将类型a转成类型b的函数，返回一个将f a转成f b的函数。除了需要支持这个fmap操作以外，该操作还要满足两个条件，就可以把f所表示的结构称为functor：</p><ol><li>单位态射（identity morphism）。即，fmap id fx = fx。fx为类型为f的任意一个实例。</li><li>态射结合性（composition morphism）。即，fmap (g1.g2) (f x) = f ((g1.g2) x)。x为其类型所在集合中的任意实例。</li></ol><p><img src="/images/scala-variance4.png" alt="upload successful"></p><p><img src="/images/scala-variance5.png" alt="upload successful"></p><p>按照我个人的理解，如果一个结构是functor，那么它能够保护其内部的数据在态射方面的一致性。</p><p>下面举个具体的栗子来说明functor性质。斯嘎喇（别名scala）中的List就是一个functor（其实scala集合类库中所有的具体类都是functor）。其中的方法mmp…不对，map正好对应操作fmap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scala&gt; val list = List(1, 2, 3)</div><div class="line">list: List[Int] = List(1, 2, 3)</div><div class="line"></div><div class="line">scala&gt; list map identity</div><div class="line">res0: List[Int] = List(1, 2, 3)</div><div class="line"></div><div class="line">scala&gt; val plusOne = (x: Int) =&gt; x + 1</div><div class="line">plusOne: Int =&gt; Int = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; val double = (x: Int) =&gt; 2 * x</div><div class="line">double: Int =&gt; Int = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; val plusOneDouble = (x: Int) =&gt; double(plusOne(x))</div><div class="line">plusOneDouble: Int =&gt; Int = &lt;function1&gt;</div><div class="line"></div><div class="line">scala&gt; list map plusOneDouble</div><div class="line">res1: List[Int] = List(4, 6, 8)</div></pre></td></tr></table></figure></p><p>尽管不能通过这种方式来证明List的functor性，但至少可以看出，在Int类型上使用的函数也可以通过map应用到List[Int]身上，语义是，把列表中的每一项作为函数参数，调用该函数，返回结果列表。</p><p>逆变函子（contravariant functor），倒是很反直觉：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Contravariant</span> f <span class="keyword">where</span></span></div><div class="line"><span class="title">contramap</span> :: (b -&gt; a) -&gt; (f a -&gt; f b)</div></pre></td></tr></table></figure></p><p>需要满足的性质和functor类似。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>同样命名为协变逆变，二者之间到底有什么联系呢？再看一次（协变）functor fmap的类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; (f a -&gt; f b)</div></pre></td></tr></table></figure></p><p>由于(-&gt;)运算符是右结合的，所以括号加上也一样。</p><p>scala协变描述：<strong>如果某个类A继承了B类，则可以说F[A]继承了F[B]</strong>。</p><p>继承关系可以看作是态射！在scala所有的类和特质这个集合中的态射！如此一来，fmap对应了前一句“如果..则..”的过程，而functor就是，需要协变的F类。顺便一提，Function1是一个profunctor。</p><p>好吧。其实也不是什么了不起的发现。（猫论还是有点意思的）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忍不住记录一下入坑以来的心动时刻。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="scala" scheme="tangenta.github.io/tags/scala/"/>
    
      <category term="猫论" scheme="tangenta.github.io/tags/%E7%8C%AB%E8%AE%BA/"/>
    
      <category term="FP" scheme="tangenta.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API</title>
    <link href="tangenta.github.io/2018/08/12/Java%E5%8F%8D%E5%B0%84API/"/>
    <id>tangenta.github.io/2018/08/12/Java反射API/</id>
    <published>2018-08-12T08:35:00.000Z</published>
    <updated>2018-08-13T09:35:09.216Z</updated>
    
    <content type="html"><![CDATA[<p>整体把握反射。本文整理自<a href="https://docs.oracle.com/javase/tutorial/reflect/" target="_blank" rel="external">龟壳公司的Java反射教程</a>。<br><a id="more"></a></p><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射（reflection），通常用于描述一段代码，它具有能够检查同一个系统中其他代码的能力。</p><p>Java的反射常常被用于需要检验和修改运行时行为的程序，这使得它们能够<strong>在运行时</strong>检验和调用类、方法、属性等。</p><p>用一句虽说可能不太恰当但直观的话来说，反射就是用一个类（java.lang.Class）来描述类本身，并通过这个类的接口实现任意一个类的实例化、方法的调用，域变量的修改等。这样使得全过程发生在运行时刻，形成了“程序跑起来后再去加载类，或检验和修改已有类信息”的效果。</p><p>一般来说，反射的应用有三种：类结构的浏览器，类的动态加载器，以及调试和测试工具。</p><h2 id="类-java-lang-Class"><a href="#类-java-lang-Class" class="headerlink" title="类(java.lang.Class)"></a>类(java.lang.Class)</h2><p>在java中，类型分两种：基本（primitive）类型和引用（reference）类型，其中基本类型有8种（boolean, byte, short, int, long, char, float, double），其余的都是引用类型。</p><p><code>java.lang.Class</code>可以表示java中的任意一个类型，它没有公有构造函数，全部实例通过JVM中类加载器（class loader）的defineClass方法自动创建，并且是不可变的（immutable）。</p><h3 id="获取某个类"><a href="#获取某个类" class="headerlink" title="获取某个类"></a>获取某个类</h3><p>在运行时对一个类进行操作首先要获取这个类。具体来说，“获取某个类”指，得到这个类所对应的类型为java.lang.Class的对象。主要有几种方法：</p><ul><li>对于所有<strong>引用类型</strong>的实例对象，用<code>Object.getClass()</code>，例如<code>&quot;foo&quot;.getClass();</code></li><li>对于<strong>基本类型</strong>和<strong>没有实例</strong>的类，用<code>.class</code>，例如<code>boolean.class</code>，<code>java.io.PrintStream.class</code></li><li>从<strong>字符串</strong>获取一个类，用<code>Class.forName(&quot;xxx&quot;)</code>，例如要获取String这个类，可以<code>Class.forName(&quot;java.lang.String&quot;);</code></li></ul><p>基本类型封装器（primitive type wrapper）——即8个基本类型各自封装成的类，都有.TYPE域，用于获取其背后基本类型。例如Double.TYPE相当于double.class。</p><p>已知一个类时，java.lang.Class类提供了获取父类类型、成员类型、外围类型（enclosing class）的方法。分别是：</p><ul><li><code>Class.getSuperClass()</code>，获得父类。</li><li><code>Class.getClasses()</code>，获得所有公有类，包括继承而来的。</li><li><code>Class.getDeclaredClasses()</code>，获得所有显式声明的类。</li><li><code>Class.getDeclaringClass()</code>，获得声明它的类，匿名内部类返回null。</li><li><code>Class.getEnclosingClass()</code>，获得包裹着它的类。</li></ul><h3 id="检验类的访问控制符、泛型类型"><a href="#检验类的访问控制符、泛型类型" class="headerlink" title="检验类的访问控制符、泛型类型"></a>检验类的访问控制符、泛型类型</h3><p>访问控制符包括public，protected，private，static，abstract，final，strictfp以及注解（annotations）。<br>Class.getModifiers()返回一个整数，需要用Modifier.toString(int)来翻译成人类可读的字符串。</p><p>Class.getTypeParameters()返回一个TypeVariable数组，代表泛型类型。例如，对原型为</p><p><code>public interface ConcurrentNavigableMap&lt;K,V&gt;</code></p><p>的类对象调用getTypeParameters()得到的数组有两个元素，分别代表了K和V。</p><h3 id="查看类的成员"><a href="#查看类的成员" class="headerlink" title="查看类的成员"></a>查看类的成员</h3><p>java.lang.Class类可以查看的类成员有三种：域（field）、方法（method）和构造函数（constructor）。</p><p><img src="/images/javaReflectionAPI-inspectMember.png" alt="upload successful"></p><p>注意： <code>X getX(String name)</code>用于获取某个名字的成员。<code>X[] getXs ()</code>返回值为一个数组，包含所有满足条件的成员。</p><h2 id="成员-java-lang-reflect-Member"><a href="#成员-java-lang-reflect-Member" class="headerlink" title="成员(java.lang.reflect.Member)"></a>成员(java.lang.reflect.Member)</h2><p>java.lang.reflect下的Field、Method和Constructor实现了Member接口定义的方法。从Class获得Field、Method、Constructor的方法，见上一小节。</p><h3 id="域-java-lang-reflect-Field"><a href="#域-java-lang-reflect-Field" class="headerlink" title="域(java.lang.reflect.Field)"></a>域(java.lang.reflect.Field)</h3><p>要知道某个域的类型，可以调用<strong>Field.getType()</strong>，返回值类型为Class&lt;?&gt;。</p><p>或者调用<strong>Field.getGenericType()</strong>，返回值代表该域的泛型类型，如果有的话。返回值本身类型为reflect.Type。例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> T field;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>则<code>Test.class.getDeclaredField(&quot;field&quot;).getGenericType().getTypeName()</code>的结果为”T”。而对应<strong>getType()</strong>得到的Class对象转化为字符串（无论是toGenericString还是toString），得到的是类型被擦除的T，这里即java.lang.Object。</p><p><strong>综上，主要强调一点：getGenericXType和getXType除了返回值类型不同以外，带有“Generic”的方法会引导程序前往class文件观察签名属性（Signature Attribute）以便获取泛型类型，如果该签名属性不可用（例如没有泛型类型），则回到getXType。而没有“generic”的方法则会受到类型擦除的影响。</strong></p><p>另外注意到reflect.Type只有一个方法：getTypeName()，仅能转换为字符串。</p><p>如果要设置某个域的值，对于基本类型，用</p><p>Field.set<em>PrimitiveType</em>(Object toBeSet, <em>PrimitiveType</em> pt)。</p><p>对于引用类型，用</p><p>Field.set(Object toBeSet, Object value)。</p><h3 id="方法-java-lang-reflect-Method"><a href="#方法-java-lang-reflect-Method" class="headerlink" title="方法(java.lang.reflect.Method)"></a>方法(java.lang.reflect.Method)</h3><p>检验访问控制符和Class.getModifiers()类似，不再赘述。</p><ul><li>检验返回值类型：<strong>Method.getReturnType()/Method.getGenericReturnType()</strong></li><li>检验参数类型：<strong>Method.getParameterTypes()/Method.getGenericParameterTypes()</strong></li><li>检验异常类型：<strong>Method.getExceptionTypes()/Method.getGenericExceptionTypes()</strong></li></ul><p>Method.invoke()提供了调用该Method的途径。它接受多个参数，除了第一个参数为目标实例对象，其余参数都作为实参被传进Method的形参。例如，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">double</span> second)</span> </span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</div><div class="line">    Test t = <span class="keyword">new</span> Test();</div><div class="line">    t.getClass().getDeclaredMethod(<span class="string">"f"</span>).invoke(t, <span class="number">1</span>, <span class="number">2.0</span>);</div><div class="line">    t.f(<span class="number">1</span>, <span class="number">2.0</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中第5行和第6行都可以调用对象t的f(int, double)方法。</p><p>如果该Method对象所代表的是静态方法，invoke的第一个参数设为null。</p><p>另外可以看到，受检异常除了NoSuchMethodException和IllegalAccessException以外，还有个InvocationTargetException。这个异常在Method.invoke()调用目标方法出现异常时被抛出。要得到原异常，可以通过异常链机制InvocationTargetException.getCause()获得。</p><p>当一些方法没有访问权限时，例如访问控制符为private，还可以用Method.setAccessible()来修改访问权限。</p><h3 id="构造方法-java-lang-reflect-Constructor"><a href="#构造方法-java-lang-reflect-Constructor" class="headerlink" title="构造方法(java.lang.reflect.Constructor)"></a>构造方法(java.lang.reflect.Constructor)</h3><p>检验访问控制符和参数类型和Field、Method中的类似。</p><p>创建一个实例对象有两种方法，分别是Class.newInstance()和Constructor.newInstance()。二者的不同之处有：</p><table><thead><tr><th>Class.newInstance()</th><th>Constructor.newInstance()</th></tr></thead><tbody><tr><td>只能调用没有参数的构造函数</td><td>可以调用任意一个构造函数，参数被传递到相应的构造函数</td></tr><tr><td>可能抛出任意一个构造函数声明的异常</td><td>只会抛出InvocationTargetException</td></tr><tr><td>需要构造函数是公有的</td><td>在一些情况下可以调用私有构造函数</td></tr></tbody></table><h2 id="两种特殊类型"><a href="#两种特殊类型" class="headerlink" title="两种特殊类型"></a>两种特殊类型</h2><h3 id="数组-java-lang-reflect-Array"><a href="#数组-java-lang-reflect-Array" class="headerlink" title="数组(java.lang.reflect.Array)"></a>数组(java.lang.reflect.Array)</h3><p>java的数组也是一个引用类型，同样继承自万类之父java.lang.Object，给定一个java.lang.Class对象，判断它是不是数组的方法是Class.isArray()。数组类型在转换为字符串后常包含一个或以上的”[“，并且其个数表示数组的维数。</p><p>要获得数组元素的类型，可以用Class.getComponentType()。</p><p>利用反射建立一个数组分两步，创建和填充。</p><p>java.lang.reflect.Array提供了一系列动态建立和访问数组的静态方法。Array.newInstance()接受两个参数，第一个类型为Class，表示数组元素的类型;第二个参数可以是int（表示长度）或int…（表示数组在各个维度上的长度）。例如创建一个3行5列的Integer矩阵，可以写成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] lengths = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</div><div class="line">Array.newInstance(Integer.class, lengths);</div></pre></td></tr></table></figure></p><p>Array.set()可以用来填充数组。其原型为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object array,</span></span></div><div class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> index,</span></span></div><div class="line"><span class="function"><span class="params">                       Object value)</span></span></div><div class="line"><span class="function">                <span class="keyword">throws</span> IllegalArgumentException,</span></div><div class="line"><span class="function">                       ArrayIndexOutOfBoundsException</span></div></pre></td></tr></table></figure></p><p>除了对引用类型的get/set以外，还有对8个基本类型的get/set。形式为[get|set]<em>PrimitiveType</em>(Object array, int index)。当基本类型需要发生转换时，丢失精度的转换会触发IllegalArgumentException。</p><p>n维数组，实际上是n-1维数组的数组。因此在修改多维数组时，可以用get对n维数组拆分成n-1维数组，再做操作。</p><h3 id="枚举-java-lang-Enum"><a href="#枚举-java-lang-Enum" class="headerlink" title="枚举(java.lang.Enum)"></a>枚举(java.lang.Enum)</h3><p>在java中，所有的枚举类都继承自java.lang.Enum。</p><ul><li>Class.isEnum()，判断该类是否为枚举类。</li><li>Class.getEnumConstants()，返回类型为枚举类的数组。</li><li>Field.isEnumConstant()，判断是否为枚举类型的常量。</li></ul><p>在一般的非反射式的代码中，常用枚举类的静态成员方法values()代替Class.getEnumConstants()。</p><p>修改枚举变量用Field.get/set()。</p><hr><p>最后提供几个关于反射常见错误的官方解答(Troubleshooting)的入口：</p><ol><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classTrouble.html" target="_blank" rel="external">编译器警告</a>：泛型类型(generic type)向原类型(raw type)转换导致的不安全操作</li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classTrouble.html" target="_blank" rel="external">构造函数不可访问导致的InstantiationException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldTrouble.html" target="_blank" rel="external">类型不可转换导致的IllegalArgumentException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldTrouble.html" target="_blank" rel="external">访问非公有域导致的NoSuchFieldException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldTrouble.html" target="_blank" rel="external">修改final域导致的IllegalAccessException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodTrouble.html" target="_blank" rel="external">类型擦除导致的NoSuchMethodException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodTrouble.html" target="_blank" rel="external">调用非公有方法导致的IllegalAccessException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodTrouble.html" target="_blank" rel="external">Method.invoke()导致的IllegalArgumentException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodTrouble.html" target="_blank" rel="external">调用方法出异常导致的InvocationTargetException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorTrouble.html" target="_blank" rel="external">没有无参构造函数导致的InstantiationException</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorTrouble.html" target="_blank" rel="external">Class.newInstance()可能乱丢异常</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整体把握反射。本文整理自&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;龟壳公司的Java反射教程&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="tangenta.github.io/tags/java/"/>
    
      <category term="reflection" scheme="tangenta.github.io/tags/reflection/"/>
    
  </entry>
  
  <entry>
    <title>基础图算法BFS&amp;DFS</title>
    <link href="tangenta.github.io/2018/06/15/%E5%9F%BA%E7%A1%80%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <id>tangenta.github.io/2018/06/15/基础图算法/</id>
    <published>2018-06-15T11:04:00.000Z</published>
    <updated>2018-06-18T01:57:18.190Z</updated>
    
    <content type="html"><![CDATA[<p>期末复习。<br><a id="more"></a></p><p>最近算法课做了个期末小测验，在回答一道关于广度优先搜索和深度优先搜索相关的问题时心有点虚，所以测完后就跑去刷了一遍CLRS的相应章节。一大斤的引理、定理的证明硬是看完了，除了惊叹一下“循环的正确性”和“数学归纳法”之间的神奇联系之外，其他的都比较枯燥，估计过两天就忘了。。</p><p>这里就简单的复习一下吧：）</p><p>图的表示方法：</p><ul><li>邻接链表：由一个代表顶点集的数组，以及与每个顶点直接相连的链表组成。对于无向图G=(V,E)，其消耗的空间为|V|+|2E|。</li><li>邻接矩阵：矩阵的每个元素用0和1表示。假设A[i][j]表示第i行第j列的元素，A[i][j] = 1代表存在从第i个顶点连接到第j个顶点的边。A[i][j] = 0则表示不存在这样的边。消耗的空间为|V|×|V|。</li></ul><p><img src="/images/designorflow-graphrepresent.png" alt="upload successful"></p><p>广度优先搜索（BFS）算法顶点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></div><div class="line">Color color;  <span class="comment">// 颜色，白色-未发现;灰色-已发现未访问;黑色-已访问</span></div><div class="line">Vertex* π;<span class="comment">// 搜索树的父结点</span></div><div class="line"><span class="keyword">int</span> d;   <span class="comment">// 与源点的距离长度（路径包含的边的个数）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>BFS算法伪代码：<br><img src="/images/designorflow-bfscode.png" alt="upload successful"></p><p>意思大概是，首先初始化，将搜索起始点（s）标记为灰色、父结点为空、距离为0，其他顶点标记为白色、父结点为空、距离为正无穷（line 1-7）。</p><p>然后维持一个保存灰色结点的队列，每次拿出一个顶点（u）进行访问（line 12），访问的步骤是</p><ul><li>将它周围每一个白色（未访问的）顶点（v）标记为灰色（已发现），</li><li>（s，v）距离d = u与s的距离+1, 表示要从源点s走到这个结点v，只需要先走到u，再走一步即可到达v。</li><li>v的父节点指向u，表示v是从u这个方向探索到的。</li><li>将v放入队列中（line 14-17），等待访问。</li></ul><p>做完访问的一系列操作后，标记为黑色（已访问），转而在队列中取出下一个要访问的顶点，重复上述过程，直到队列为空。</p><p>基本性质：对于保存灰色结点的队列，所有的结点的d是一个递增序列，并且首元素和尾元素的d只相差1。</p><p>深度优先搜索（DFS）算法顶点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></div><div class="line">Color color;  <span class="comment">// 颜色，白色-未发现;灰色-已发现未访问;黑色-已访问</span></div><div class="line">Vertex* π;<span class="comment">// 搜索树的父结点</span></div><div class="line"><span class="keyword">int</span> d;<span class="comment">// 发现该节点的时间</span></div><div class="line">    <span class="keyword">int</span> f;<span class="comment">// 访问该节点的时间</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>DFS算法伪代码：</p><p><img src="/images/designorflow-dfscode.png" alt="upload successful"></p><p>DFS也分为两个部分，第一部分是初始化顶点和时间（line 1-4）。</p><p>第二部分是一个递归函数DFS-VISIT，其作用是，以图G的顶点u为局部源点，进行深度优先搜索。对于局部源点u，首先将u标记为灰色（已发现）并记录下当前时间（line 1-2），以u为中心查找它所有的邻接顶点，选出白色（未被发现的）顶点，对他们进行深度优先搜索（即递归调用DFS-VISIT）。当所有u的邻接顶点已被发现后，标记u为黑色（结束对局部源点u的访问）并记录当前时间。</p><p>由于DFS-VISIT不能保证一次搜索就能够访问所有的顶点（即使图为连通图），因此要给同一个图其他顶点作为源点的机会，第一部分的第5-7行就是这个目的。</p><p>“深度”一词体现在4-7行的循环中：拿到一个白色顶点后，未等开始寻找下一个白色顶点，就马上进入以这个白色顶点作为源点的搜索中。</p><p>基本性质：</p><ul><li>dfs搜索产生的可能是一个森林（由多颗树组成）。</li><li>dfs结束后每个顶点的d和f（发现时间和访问时间）构成的区间之间，要么是“完全不交”关系，要么是“包含”关系。</li></ul><p><img src="/images/designorflow-overlapdf.png" alt="upload successful"></p><ul><li>dfs结束后，顶点u是顶点v的祖先，当且仅当：发现u时，u和v之间有一条经过全是白色节点的路径。</li></ul><p>边的分类：</p><ul><li>树边：对于边e = Edge(u,v)，如果是v是通过e来发现的，则e是树边。</li><li>回边：由子结点指向父结点的非树边。</li><li>前向边：由父结点指向子结点的非树边。（无向图没有）</li><li>横跨边：所有其他的边。（无向图没有，连通分支上运用dfs只能产生一棵树）</li></ul><p>判断边类型的方法：在第一次探索边e=Edge(u,v)时，如果v是白色，则e是树边;如果v是灰色，则e是回边;如果v是黑色，则e是前向边或者横跨边。</p><p>相关的证明可以参考《算法导论》（CLRS）的基础图算法一章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;期末复习。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="tangenta.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>构建四则运算语法树——递归方法</title>
    <link href="tangenta.github.io/2018/03/06/%E6%9E%84%E5%BB%BA%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%AF%AD%E6%B3%95%E6%A0%91%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95/"/>
    <id>tangenta.github.io/2018/03/06/构建四则运算语法树——递归方法/</id>
    <published>2018-03-06T05:21:00.000Z</published>
    <updated>2018-03-29T15:50:31.622Z</updated>
    
    <content type="html"><![CDATA[<p>Language: C with class with stl with template with namespace.</p><a id="more"></a><p>前两天浏览了一位老友G的blog：<a href="http://gaufoo.com/2018/01/02/ni_to_pre_post/" target="_blank" rel="external">中缀表达式转化前后缀引发的思考</a></p><p>内容大概是四则运算语法树的优雅实现，看完后闻到了一股浓郁的…C的味道。为了消除诸如指针的引用、变量名大写等骚操作带来的不适感，忍不住重新实现了一遍。</p><p>本次实现借鉴(chao xi)了G的整体架构，包括类结构、函数式风格以及…变量命名——等。</p><p><img src="/images/calculate-tree-recursive.png" alt="upload successful"><br>（图片来自<a href="http://gaufoo.com/2018/01/02/ni_to_pre_post/）" target="_blank" rel="external">http://gaufoo.com/2018/01/02/ni_to_pre_post/）</a></p><p>稍有不同的地方是，与“G对表达式字符串扫描一次完成建立”相对应，我采用的是字符串的切割和构造来建立语法树。尽管这需要相对较大的开销，但我认为用这种方式来代替扫描逐个字符的做法更能突出中心思想。</p><p>待处理的算术表达式记为expression。</p><p>观察:</p><ul><li>一个expression由零或以上个factors通过+或-连接而成。</li><li>每个factor则由零或以上个terms通过*或/连接而成。</li><li>这里term是表达式的基本单位，它是一个操作数或者有括号括在最外围的整体。</li><li>此外，括号括在最外围的任意整体的内部，即除去括号后，都被归为expression。</li></ul><p>类型定义：正如上图所示，以Expr作为基类，派生出BinExpr和NumExpr。</p><p>BinExpr包含三个数据成员:运算符、第一个操作表达式和第二个操作表达式。</p><p>NumExpr仅包含一个数据成员，即值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Expr</span> &#123;</span></div><div class="line">    <span class="keyword">virtual</span> ~Expr() = <span class="keyword">default</span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinExpr</span> :</span> <span class="keyword">public</span> Expr &#123;</div><div class="line">    BinOperPtr op;</div><div class="line">    ExprPtr fst;</div><div class="line">    ExprPtr snd;</div><div class="line">    BinExpr(BinOperPtr op_p, ExprPtr fst_p, ExprPtr snd_p)</div><div class="line">        : op(op_p), fst(fst_p), snd(snd_p) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExpr</span> :</span> <span class="keyword">public</span> Expr &#123;</div><div class="line">    <span class="keyword">double</span> value;</div><div class="line">    NumExpr(<span class="keyword">double</span> v) : value(v) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>语法树结构：二元算术运算中，语法树是二叉树。每个结点(Expr)既有可能是一颗子树(BinExpr)，也可能是叶子(NumExpr)。</p><p>实现思路如下：</p><p>以二叉树为骨架意味着，必然存在指针。为堆资源管理方便起见，采用智能指针shared_ptr。相应调整并确定Expr，BinExpr和NumExpr的结构后，开始实现三个核心函数：getExpr，getFactor和getTerm。它们的作用是，将expression、factor、和term转换为一个结点指针(ExprPtr)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExprPtr <span class="title">getExpr</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div><div class="line"><span class="function">ExprPtr <span class="title">getFactor</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div><div class="line"><span class="function">ExprPtr <span class="title">getTerm</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div></pre></td></tr></table></figure><p>可以看到，他们的参数都是字符串。当然，这些字符串要满足一定的要求才能被传入函数中。各个函数对参数的要求如下：</p><ul><li>getExpr：只要满足expression的描述即可。(例如xxx +/- xxx)</li><li>getFactor：要求参数满足factor的描述。（如不能存在游离在括号外面的+或-）</li><li>getTerm：要求参数满足term的描述（如一个数，或者括号括起来一坨东西的整体，包括括号）。</li></ul><p>和一般(利用栈)建立语法树方法不同，这里的主要思路是，每次首先找出满足条件的二元运算符，以它为中心，切割两边的字符串，再分别”递归”应用getExpr/getFactor/getTerm。（即解析字符串的时候可能存在直接或间接的递归）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExprPtr <span class="title">getExpr</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span> &amp;expr)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> operIndex = getOper(expr, <span class="string">"+-"</span>);</div><div class="line">    <span class="keyword">if</span> (operIndex == <span class="number">0</span>) &#123; <span class="comment">// "+" or "-" not found</span></div><div class="line">        <span class="keyword">if</span> (parentheseExpr(expr))</div><div class="line">            <span class="comment">// strip outermost parenthese marks</span></div><div class="line">            <span class="keyword">return</span> getExpr(stripEnds(expr));</div><div class="line">        <span class="comment">// must be a factor</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> getFactor(expr);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// found "+" or "-" as a binary operator</span></div><div class="line">    <span class="keyword">auto</span> operIter = expr.begin() + operIndex;</div><div class="line"></div><div class="line">    BinOperPtr opExpr = char2BinOper(expr[operIndex]);</div><div class="line">    ExprPtr leftExpr = getFactor(<span class="built_in">string</span>(expr, <span class="number">0</span>, operIndex));</div><div class="line">    ExprPtr rightExpr = getExpr(<span class="built_in">string</span>(operIter + <span class="number">1</span>, expr.end()));</div><div class="line">    <span class="keyword">return</span> make_shared&lt;BinExpr&gt;(opExpr, leftExpr, rightExpr);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用人话说一遍：面对一个expression，首先拿到其中第一个（游离在括号外的）‘+-’运算符，用它之前的字符串构造一个factor，再用它之后的字符串构造一个expression，把三者粘成一颗树并返回。</p><p>实现细节：</p><p>括号处理——由于括号内的表达式具有最高优先级，因此连括号一起看，它是个term;一旦没了括号，它里面的内容就成了expression。可以想象，遇到含有括号的表达式(字符串)时，分两种情况:</p><ul><li>一种是括号存在于最外围，这时剥去括号并对其内容应用getExpr即可。</li><li>另一种是括号不在最外围，这种情况下，只要这个表达式合法，可以断言：必定存在一个二元运算符。要获得这个运算符，首先要屏蔽掉括号内相同运算符的影响。故设定一个屏蔽开关，分别由左括号控制开、右括号控制关，仅当开关处于关闭状态且目标满足要求时返回。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> getOper(<span class="built_in">string</span> <span class="keyword">const</span> &amp;expr, <span class="built_in">string</span> <span class="keyword">const</span> &amp;ops) &#123;</div><div class="line">    <span class="keyword">bool</span> enable = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != expr.size(); ++i) &#123;</div><div class="line">        <span class="keyword">char</span> ch = expr[i];</div><div class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>) <span class="comment">// ignore entities wrapped by parentheses</span></div><div class="line">            enable = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>)</div><div class="line">            enable = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (enable &amp;&amp; count(begin(ops), end(ops), ch) == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// such a binary operator doesn't exist</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输入异常(烂尾)——这里将异常为三类：二元运算符缺操作数(“3+” “-+”)、包含未知字符(“%&amp;?”)以及括号不匹配(缺左括号、右括号或”)(“)。处理方案是首先进行表达式合法性检查。</p><p>（ps： 后来发现还有”()()”，”3(2)”这些坑爹情况，关于如何一次性完成表达式的合法性检查这个问题，如果有好的想法，请email：tangenta@126.com）</p><p>总结：使用函数以递归的方式建立起语法树，与一般栈方法相比，在代码中更清晰地描述了语法树的结构(例如”一个expression由factor、加减运算符及另一个expression组成”)，构建的过程也更加直观易懂，而不像栈方法——规定了每种数字符号出现时作出的响应。</p><p>但是在另一方面，函数方法在性能上不如栈方法。在这个栗子中，除了函数调用开销以外，还有字符串构造析构产生的消耗。</p><p>从某种程度上来说，递归方法和一般方法的差别有点类似于递归过程(recursive procedure)中“递归(recursive process)”和“迭代(iterative process)”之间的区别。</p><p>最后，无源码不丈夫：<a href="https://github.com/tangenta/toy/blob/master/syntatic-tree.cpp" target="_blank" rel="external">github</a>.</p><ul><li>Ex1-1: 上面文章和代码存在着一个惊天大bug，请简述之。<br><br><br><br><br><br><br><br><br><br><br><br><br><br></li></ul><p>solution：getOper从左往右找到第一个二元运算符恰恰违反了算术运算中同级运算符从左至右的计算顺序。以这个运算符作为分割点，右半部分被再次应用getExpr，<strong>在它计算完毕后（合成了一颗新的子树）</strong>，才与运算符、左半部分结合形成新的树，这意味着同级运算符右边的计算顺序<strong>先于</strong>左边。</p><p>解决方案：getOper应从右往左寻找第一个二元运算符，并且对左半部分应用getExpr，右半部分应用getFactor。getFactor同理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Language: C with class with stl with template with namespace.&lt;/p&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>TLPI-File I/O</title>
    <link href="tangenta.github.io/2018/01/24/TLPI-File-I-O/"/>
    <id>tangenta.github.io/2018/01/24/TLPI-File-I-O/</id>
    <published>2018-01-24T15:14:00.000Z</published>
    <updated>2018-02-03T02:44:31.869Z</updated>
    
    <content type="html"><![CDATA[<p>这一章介绍的接口有：open、read、write、close、lseek、ioctl、fcntl、dup/dup2、pread/pwrite、readv/writev、msktemp。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文件和文件标识符"><a href="#文件和文件标识符" class="headerlink" title="文件和文件标识符"></a>文件和文件标识符</h3><p>文件标识符（file descriptor，常用fd表示）是一个非负整数，程序中用于表示已经被打开了的所有文件。这里的“文件”包括pipes，FIFOs，sockets，terminals，devices等等。每一个进程都有独立的文件标识符集合。</p><p>每一个程序启动时都默认打开了三个文件，分别是标准输入流、标准输出流以及标准错误流，对应的正整数为0,1,2。</p><p><img src="/images/fileio-standardfiledescriptor.png" alt="upload successful"></p><p>文件标识符与已打开文件的关系：在unix系统中，有三个结构由内核维护，分别是：单个进程内的文件标识符表（per-process fd table）、系统范围的“已打开文件”表（open file description table）、文件系统节点表（i-node table）。为方便期间，下面简称表一、表二、表三。</p><ul><li>单个进程内的文件标识符表（表一）：存在于每个进程中，每个单元表示<strong>被该进程打开着</strong>的文件。包含的信息有，文件标识符控制标记（这里只有close-on-exec？）和指向表二中某一单元的指针。</li><li>系统范围的“已打开文件”表（表二）：存在于整个系统中，代表系统中所有<strong>被打开着</strong>的文件。包含当前文件指针偏移量、文件状态属性、文件访问控制权限、信号驱动IO设置，和指向表三中某一单元的指针。</li><li>文件系统节点表（表三）：表示系统中<strong>所有</strong>的文件。包含文件类型、访问权限、文件锁列表指针、文件属性（大小、时间戳等）等。</li></ul><p>下图表明了三者之间的联系：</p><p><img src="/images/fileio-filedescriptor-tables.png" alt="upload successful"></p><p>简单总结一下特点：</p><ol><li>同一进程的不同标识符可以指向同一个被打开着的文件，如进程A的 fd0 和fd20，可以用重定向（dup/dup2/fcntl）实现; </li><li>不同进程的标识符也可以指向同一个被打开着的文件，如 A::fd2 和 B::fd2，例如fork。</li><li>不同的“被打开着的文件”可以指向同一个文件。例如open同一个文件多次。</li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在系统接口编程中，如果一个函数或程序片段满足原子性，则CPU在执行这一片段的过程不会被打断（不会进行进程间代码执行的切换，或称上下文切换（context switch））。所有的系统函数都满足原子性。</p><p>原子性可以避免进程间的竞争冲突。例如两个进程同时对一个文件作写入操作，如果CPU在执行系统函数的过程中不断地切换上下文，最终会导致文件内容在顺序上不可预测。</p><h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p>与文件输入输出相关的系统函数主要有以下几个：</p><table><thead><tr><th>system_call_name(Type1 arg1, Type2 arg2, …) -&gt; ReturnType</th></tr></thead><tbody><tr><td>打开文件    <code>open(const char* pathname, int flags, .../* int mode */) -&gt; int fd</code></td></tr><tr><td>读取文件    <code>read(int fd, const char* buffer, int count) -&gt; int numread</code></td></tr><tr><td>写入文件    <code>write(int fd, const char* buffer, int count) -&gt; int numwritten</code></td></tr><tr><td>关闭文件    <code>close(int fd) -&gt; int status</code></td></tr><tr><td>改变文件指针 <code>lseek(int fd, off_t offset, int whence) -&gt; off_t ofs</code></td></tr><tr><td>设备控制 <code>ioctl(int fd, int request, ... /* argp */) -&gt; int *depend on request*</code></td></tr><tr><td>查询/修改文件信息 <code>fcntl(int fd, int cmd, ...) -&gt; int *depend on cmd*</code></td></tr></tbody></table><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>打开文件。</p><p><img src="/images/fileio-open.png" alt="upload successful"></p><ul><li>pathname：文件所在路径，如果是快捷方式，则找到源文件。</li><li>flags： 指定了访问方式，其中必须包含只读（O_RDONLY）、只写（O_WRONLY）和读写（O_RDWR）三种方式中的一种。其余的用位或（|）的方式指定。</li><li>mode（可选）：指定了新文件的访问权限，仅当flag包含O_CREAT时有效。</li></ul><p>flags：<br><img src="/images/fileio-open-flags.png" alt="upload successful"></p><p>这里的flags分三类：</p><ul><li>第一类是读写控制部分，占用flags的低2位。</li><li>第二类用于open的功能标志，制定了open应以什么方式工作，例如非目录报错（O_DIRECTORY）、清空文件内容（O_TRUNC）等。不能被fcntl获取或修改。</li><li>第三类是文件状态，指定了文件的属性。</li></ul><p>[注意] 如果想让程序独占（exclusively）创建文件时（即如果文件不存在，则创建并打开它; 如果文件存在，则不做动作），一个常见的错误是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>], O_WRONLY, mode)) != <span class="number">-1</span>) &#123; <span class="comment">// 打开成功（文件存在）</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"file already exists\n"</span>);</div><div class="line">    close(fd);</div><div class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 打开失败（文件不存在或者其他错误）&lt;--context switch</span></div><div class="line">    <span class="keyword">if</span> (errno != ENOENT)</div><div class="line">        errExit(<span class="string">"open"</span>);<span class="comment">//其他错误</span></div><div class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT, mode)) == <span class="number">-1</span>)</div><div class="line">        errExit(<span class="string">"open"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"create file exclusively\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>乍一看这代码应该没什么问题。但是，仔细观察可以发现，整个程序片段不满足原子性。就是说，可能存在进程间的竞争冲突。例如，执行到箭头位置时，另一个进程创建了argv[1]对应的这个文件，导致第1行判断失效。</p><p>这时，直接使用O_EXCL来打开文件可以解决这个问题：</p><p><code>open(argv[1], O_WRONLY | O_CREAT | O_EXCL, mode);</code></p><p>当文件存在时返回-1。另外，由于是单个系统函数，满足原子性。同理，O_APPEND也有类似的用途，解决了文件末尾写入的竞争冲突问题。</p><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>读取文件内容。</p><p><img src="/images/fileio-read.png" alt="upload successful"></p><ul><li>fd：文件标识符，从这里读出数据。</li><li>buffer：缓冲区，用于存放从文件中读出的信息。系统函数通常不会在它的内部分配空间，因此，为了实现系统函数和调用者（caller）之间的信息传递，需要调用者预先分配空间。</li><li>count：需要读出的字节数。</li><li>ssize_t是有符号的size_t。</li></ul><p>[注意] 在用read将文件的内容以字符串的形式输出（printf(“%s”, buffer)）时，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_READ 20</span></div><div class="line"><span class="keyword">char</span> buf[MAX_READ];</div><div class="line"><span class="keyword">if</span> (read(fd, buf, MAX_READ) == <span class="number">-1</span>)</div><div class="line">errExit(<span class="string">"read"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"The input data is: %s"</span>, buf);</div></pre></td></tr></table></figure></p><p>这样写并不能正常地输出文件中的内容，原因是read不会自动添加’\0’到buf末尾（read：我怎么知道你是以字符形式读出？）。一个比较好的处理方法是，缓冲长度设为MAX_READ+1并手动添加’\0’。</p><h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><p>向文件写入内容。</p><p><img src="/images/fileio-write.png" alt="upload successful"></p><p>参数含义与read()的一致。</p><p>[注意] 如果write成功执行（无错误），不保证写入fd的字节数等于count。磁盘空间不足，或者该进程打开的文件有大小限制，都可能导致write的返回值小于count。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>关闭文件。</p><p><img src="/images/fileio-close.png" alt="upload successful"></p><p>任何时候调用close，都应该检查它的返回值。</p><p>显式关闭不再被使用的文件，养成良好的编程习惯从我做起。</p><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h3><p>改变文件指针位置。</p><p><img src="/images/fileio-lseek.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>offset：偏移量（字节）。</li><li>whence：指定了偏移量从哪里开始算。whence的值可以为以下三种之一：<ul><li>SEEK_SET，从头算。</li><li>SEEK_CUR，从现在的位置算。</li><li>SEEK_END，从文件末尾开始算。</li></ul></li></ul><p><img src="/images/fileio-lseek-whence.png" alt="upload successful"></p><p>[注意] lseek不能被使用在pipe、FIFO、socket或者terminal中，否则errno被置为ESPIPE。</p><p>文件洞： lseek函数通过指定whence为SEEK_END，可以将文件指针移到没有数据的地方。这时如果向文件写入一些内容，原文件的末尾和新内容的开头之间就形成了空洞，文件体积（size）也随之变大; 但是这些空洞不占据磁盘空间。</p><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl()"></a>ioctl()</h3><p>用于设备的I/O控制，作为标准IO模型的补充。</p><p><img src="/images/fileio-ioctl.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>request：运作方式，每个设备都定义了独立的常量。其中的信息包含：输入/输出，argp的大小（字节）。</li><li>argp：指向内存的指针。类型取决于request，通常用作输入输出缓冲。</li></ul><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p><img src="/images/fileio-fcntl.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>cmd：决定了运作方式和第三个参数的类型。</li></ul><h4 id="获取-修改文件的flags"><a href="#获取-修改文件的flags" class="headerlink" title="获取/修改文件的flags"></a>获取/修改文件的flags</h4><p>（这里只能获取第一类和第三类flags，见open()一节）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> flags, accessmode;</div><div class="line">flags = fcntl(fd, F_GETFL);</div><div class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>) errExit(<span class="string">"fcntl"</span>);</div></pre></td></tr></table></figure></p><p>检验第一类（访问控制）flags：</p><p><code>if (flags &amp; O_SYNC) printf(&quot;writes are synchronized.\n&quot;);</code></p><p>检验第三类（文件状态）flags：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">accessmode = flags &amp; O_ACCMODE;</div><div class="line"><span class="keyword">if</span> (accessmode == O_WRONLY || accessmode == O_RDWR)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"file is writable.\n"</span>);</div></pre></td></tr></table></figure></p><p>[注意] 由于三个模式只占flag的低2位，这里不能简单地<code>flag &amp; O_xxx</code>。</p><p>修改flags的过程是获取并重新设置flags的过程。要设置flags，只需将fcntl的cmd部分改为<strong>F_SETFL</strong>，并把flags作为第三个参数即可：<br><code>fcntl(fd, F_SETFL, flags);</code></p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>功能类似于dup/dup2，cmd设为<strong>F_DUPFD</strong>，用法如下：</p><p><code>newfd = fcntl(oldfd, F_DUPFD, startfd);</code></p><p>作用是从startfd开始，在所有数值上大于startfd的标识符中选择最小可用的fd，使它指向oldfd指向的内容，返回新的标识符。这时对新标识符的读写相当于对oldfd的读写。</p><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup()/dup2()"></a>dup()/dup2()</h3><p>产生一个新的文件标识符，使其指向已有的被打开着的文件。</p><p><img src="/images/fileio-dup.png" alt="upload successful"></p><p><img src="/images/fileio-dup2.png" alt="upload successful"></p><ul><li>oldfd：文件标识符，指向已被进程打开了的文件。</li><li>newfd：新的文件标识符。</li></ul><p>dup与dup2不同之处在于，dup把可用的（即未绑定打开着的文件）数值上最小的文件标识符用作新的标识符。另外，dup2会将newfd指向的文件（如果有）关闭（忽略关闭错误），除非oldfd不可用。</p><h3 id="pread-pwrite"><a href="#pread-pwrite" class="headerlink" title="pread()/pwrite()"></a>pread()/pwrite()</h3><p>不改变文件指针位置的读写方式。</p><p><img src="/images/fileio-pread-pwrite.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>buf：缓冲区。</li><li>count：读出/写入的最大字节数。</li><li>offset：文件指针偏移量（从文件开头计算）。</li></ul><p>pread/pwrite的引入将lseek和read/write结合起来并赋予了原子性，避免了多线程环境下的读写竞争冲突。同时，在性能上也有所提高。</p><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv()/writev()"></a>readv()/writev()</h3><p>集散I/O：在一个系统调用中完成多个缓冲区的读取/写入。</p><p><img src="/images/fileio-readv-writev.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>iov：一些列缓冲区的集合。</li><li>iovcnt：缓冲区集合的个数。</li></ul><p>第二个参数的结构如下图所示：</p><p><img src="/images/fileio-readv-writev-iov.png" alt="upload successful"></p><p>iov_base和iov_len分别指定了缓冲区的首地址和缓冲区的长度。缓冲区可以是所有类型的变量，包括结构体、整数、字符串等。</p><h3 id="truncate-ftruncate"><a href="#truncate-ftruncate" class="headerlink" title="truncate()/ftruncate()"></a>truncate()/ftruncate()</h3><p>设置文件为指定大小。</p><p><img src="/images/fileio-truncate-ftruncate.png" alt="upload successful"></p><ul><li>pathname：文件路径。</li><li>fd：文件标识符。</li><li>length：文件大小（字节）。</li></ul><p>如果length小于原文件大小，则多出的部分被丢弃; 如果length大于原文件大小，剩余部分则填充’\0’或者作为文件洞。truncate/ftruncate要求文件可访问、可写。另外，文件指针不会被改变。</p><h3 id="msktemp"><a href="#msktemp" class="headerlink" title="msktemp()"></a>msktemp()</h3><p>建立一个临时文件。</p><p><img src="/images/fileio-mkstemp.png" alt="upload successful"></p><ul><li>template：字符数组，内容为路径，最后六个字符必须为XXXXXX。函数结束时最后六个字符被替换为随机字符，使得文件名唯一。</li></ul><p><code>&lt;stdio.h&gt;</code>中的<code>FILE* tmpfile(void)</code>也有类似的功能，但更为简便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章介绍的接口有：open、read、write、close、lseek、ioctl、fcntl、dup/dup2、pread/pwrite、readv/writev、msktemp。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="tlpi" scheme="tangenta.github.io/tags/tlpi/"/>
    
  </entry>
  
  <entry>
    <title>TLPI-系统编程概念</title>
    <link href="tangenta.github.io/2018/01/21/TLPI-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>tangenta.github.io/2018/01/21/TLPI-系统编程概念/</id>
    <published>2018-01-21T03:15:00.000Z</published>
    <updated>2018-06-18T01:57:41.290Z</updated>
    
    <content type="html"><![CDATA[<p>system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。</p><a id="more"></a><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统函数（system call）是进程向内核请求服务的入口，是系统编程的接口（API）。内核提供各种各样的服务，例如创建新进程、实行IO操作、进程间通信等等。</p><p>系统调用有如下特征：</p><ul><li>每次进行系统调用，都会将处理器的状态从“用户模式”转换为“内核模式”。</li><li>系统函数的集合是固定的，每个系统函数都由独一无二的数字标识。</li><li>每个系统函数原型都包含一个或多个形参。</li></ul><p>在C语言中，系统函数调用的过程：</p><ol><li>调用C函数库中的封装函数</li><li>封装函数保证调用系统函数时对应参数位置的正确性</li><li>调用系统函数前，封装函数将系统函数对应的数字赋值到寄存器eax中</li><li>执行trap机器指令（0x80），导致程序计数器跳转到0x80，处理器模式也从用户模式转换为内核模式</li><li>开始调用system_call()。它作出下列行为：<ul><li>寄存器的值入栈。</li><li>检验系统调用的合法性。</li><li>根据sys_call_table找到并调用相应的系统函数。</li><li>恢复寄存器值，系统函数的返回值入栈。</li><li>返回到封装函数，切换模式。</li></ul></li><li>系统调用被反应到全局变量errno，从封装函数返回</li></ol><p>[注] 通常情况下，调用系统函数的开销是普通函数的数十倍。</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>库函数是C标准库中的重要组成部分。其中既包括与系统函数无关的函数，例如字符串处理函数; 又有系统函数的封装器，例如fopen，printf，malloc，free等等——这类库函数通常为简化系统函数的使用而被设计出来。</p><h3 id="系统-库函数的错误处理"><a href="#系统-库函数的错误处理" class="headerlink" title="系统/库函数的错误处理"></a>系统/库函数的错误处理</h3><p>除了测试返回值以外，多数系统函数在出现异常时会设置全局变量errno（通常与<code>&lt;errno.h&gt;</code>中定义的常量配合使用）。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cnt = read(fd, buf, numbytes);</div><div class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>) &#123;</div><div class="line"><span class="keyword">if</span> (errno == EINTR)</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read was interrupted by a signal\n"</span>);</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">/* Some other error occurred */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>&lt;errno.h&gt;</code>中定义的所有表示错误的常量都以E开头。man手册中，每一个系统函数的ERRORS部分标注了所有可能产生的错误。例如close(int fd)：</p><p><img src="/images/systemconcept-close-error.png" alt="upload successful"></p><p>[注意] errno表示<strong>上一次</strong>错误的数字代号。也就是说，如果系统调用正常返回，它不会对errno进行重设。因此，在使用errno之前，都应当先检查返回值。<br>此外，还有一种常见的错误使用errno的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"somacall() failed\n"</span>);</div><div class="line">    <span class="keyword">if</span> (errno == ...) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>错误之处在于printf可能会重设errno。用C++的话来说，这不是异常安全的。<br>正确写法是第一步先保存errno的值。</p><p>[注意] 不要手动声明errno(即<code>extern int errno;</code>)，而应该使用<code>#include &lt;errno.h&gt;</code>的方式声明。</p><h4 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg )</span></span>;</div></pre></td></tr></table></figure><p>输出字符串msg和errno对应的描述到标准错误流上。</p><p><img src="/images/systemconcept-perror.png" alt="upload successful"></p><h4 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns pointer to error string corresponding to errnum</span></div></pre></td></tr></table></figure><p>遇到未知错误代码时，返回的字符串为“unknown error nnn”。但在一些strerror实现中，也有可能是NULL。</p><p><img src="/images/systemconcept-strerror.png" alt="upload successful"></p><p>[注意] 部分库函数遇到错误不会设置errno，这种情况下，不应使用perror()或strerror()来检查错误。</p><h3 id="常用头文件和错误处理函数"><a href="#常用头文件和错误处理函数" class="headerlink" title="常用头文件和错误处理函数"></a>常用头文件和错误处理函数</h3><p>perror和strerror功能分别是输出错误信息和翻译错误码，但在linux系统编程中仅仅有这两个是不够方便的。下面给出几个实用的错误报告函数（它们的实现在这里：<a href="https://gitee.com/tangenta/TLPI-study-notes/blob/master/tlpi_hdr.h" target="_blank" rel="external">tlpi-hdr.h</a>）：</p><ul><li><strong><code>void errMsg(const char* format, ...)</code></strong>： 有格式控制输出的perror()</li><li><strong><code>void errExit(const char* format, ...)</code></strong>： errMsg后退出程序</li><li><strong><code>void err_exit(const char* format, ...)</code></strong>： 类似errExit，退出时<strong>不刷新</strong>stdout缓冲区</li><li><strong><code>void errExitEN(int errnum, const char* format, ...)</code></strong>： 用errnum代替errno的errExit(多线程中，errno是函数调用，使用errExitEN()有利于提高效率)</li><li><strong><code>void fatal(const char* format, ...)</code></strong>： 用来诊断通用错误（即包括不会设置errno的错误），<strong>不使用</strong>errno，采用errExit退出程序。</li><li><strong><code>void usageErr(const char* format, ...)</code></strong>： 字符串前置”Usage:”</li><li><strong><code>void cmdLineErr(const char* format, ...)</code></strong>： 用于表示命令行参数错误</li></ul><p>下面是命令行解析函数（分别是int和long）：</p><ul><li><strong><code>int getInt(const char* arg , int flags , const char* name)</code></strong></li><li><strong><code>long getLong(const char* arg , int flags , const char* name)</code></strong></li></ul><p>如果arg指向的字符串不能被转换为整数，则报错并终止程序。</p><p>flag可以设定<strong>大小</strong>——非负(GN_NONNEG)、正(GN_GT_0)和<strong>进制</strong>——任意进制(GN_ANY_BASE)、八进制(GN_BASE_8)、十六进制(GN_BASE_16)。大小和进制可以用或（|）来同时设定。</p><p>name可以自己设定，输出结果以…(in <em>name</em>)…显示。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul><li><p>特性检测宏(feature test macros)</p><p>  由于不同的标准主导了系统函数和库函数的API，要使程序具有可移植性，就要做到在头文件中只暴露某些平台相关的定义。</p><p>  可以通过<code>#define xxx</code>或者在编译选项加上<code>-D xxx</code>，让程序得以在遵循这些标准的系统上正常运行。</p></li><li><p>系统数据类型(system data type)</p><p>  我们常常可以看到一些typedef，例如size_t，pid_t等等，应用这些数据类型而非直接使用C语言中的int，long的原因就是能够提高可移植性。例如存放进程ID，有些系统需要4个字节的空间，另一些则用8个字节。我们写程序时可以用pid_t来消除“用int还是long”的麻烦。</p><p>  用printf输出这些数据类型时，由于程序在运行时无法得知“系统数据类型”对应的“C类型”，用”%d”还是用”%ld”就成了问题。一个解决方案是，对所有系统数据类型变量先强制转换为long，以”%ld”的形式输出。</p></li></ul><ul><li><p>结构体</p><p>  一些标准中的部分结构体没有指定内部成员的相对次序。在初始化时，为了提高可移植性，不应使用 <code>struct somestruct s = {a1, a2, a3}</code> 这种形式，而应显式初始化。</p></li></ul><ul><li><p>非通用的宏</p><p>  有些宏不是在所有实现都有定义。使用它们的时候应用<code>#ifdef xxx</code>包裹起来。</p></li><li><p>头文件</p><p>  同一个定义在不同的标准下，可能会位于不同的头文件中。为了尽可能提高可移植性，可以考虑包含多个标准指定的头文件。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="tlpi" scheme="tangenta.github.io/tags/tlpi/"/>
    
  </entry>
  
  <entry>
    <title>GDB奇技淫巧</title>
    <link href="tangenta.github.io/2017/12/26/gdb-trick/"/>
    <id>tangenta.github.io/2017/12/26/gdb-trick/</id>
    <published>2017-12-26T02:00:00.000Z</published>
    <updated>2018-01-24T09:53:40.879Z</updated>
    
    <content type="html"><![CDATA[<p>学会了这个，调试速度马上提高1.005倍！点击阅读原文</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="执行外部shell命令"><a href="#执行外部shell命令" class="headerlink" title="执行外部shell命令"></a>执行外部shell命令</h3><p>在不退出gdb的情况下执行/bin/sh命令(无视alias，用起来可能不是特别方便)：</p><p><code>(gdb)!clang++ test.cpp -o test</code> </p><p>或者</p><p><code>(gdb)shell clang++ test.cpp -o test</code></p><hr><h3 id="记录调试信息"><a href="#记录调试信息" class="headerlink" title="记录调试信息"></a>记录调试信息</h3><p>将调试产生的输出保存到文件中(file默认是gdb.txt)，便于日后分析：</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set logging on/off</td><td>调试信息记录开启/关闭</td></tr><tr><td>set logging file [file]</td><td>设置保存记录的文件名</td></tr></tbody></table><hr><h3 id="设置程序启动参数"><a href="#设置程序启动参数" class="headerlink" title="设置程序启动参数"></a>设置程序启动参数</h3><p>程序运行参数太多，每次run要写一堆参数？exec-wrapper或args解放双手：</p><ul><li>exec-wrapper：存放了用于启动程序的shell命令。在gdb中运行run时，通过exec-wrapper来启动程序，然后将控制权转交给gdb。如果exec-wrapper为空，则会执行已被连接的target(即默认情况)。</li><li>args：存放了需要传递给被调试程序的参数。运行run时，args内的字符串被当作参数传递给程序。</li></ul><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>show args</td><td>显示run附带的参数</td></tr><tr><td>show exec-wrapper</td><td>显示exec-wrapper的内容</td></tr><tr><td>set exec-wrapper “./a.out -arg”</td><td>设置启动命令为”./a.out -arg”</td></tr><tr><td>set args “-arg1 -arg2 -arg3”</td><td>设置运行参数为”-arg1 -arg2 -arg3”</td></tr><tr><td>unset exec-wrapper</td><td>删除exec-wrapper</td></tr></tbody></table><hr><h3 id="存档机制"><a href="#存档机制" class="headerlink" title="存档机制"></a>存档机制</h3><p>调试错过了翻车地点？存档机制逆转时空，restart一下就好了，不必重新运行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>checkpoint</td><td>保存当前程序状态(通过fork实现)</td></tr><tr><td>info checkpoints</td><td>查看存档信息(每个checkpoint都有自己的id)</td></tr><tr><td>restart checkpoint-id</td><td>恢复第checkpoint-id个存档的信息</td></tr><tr><td>delete checkpoint checkpoint-id</td><td>删除第checkpoint-id个存档的信息</td></tr></tbody></table><p>注意：恢复程序的状态不包括恢复pid值、对外部文件或进程的操作。例如打印到文件流的信息不能被吸回来，删掉的外部文件不能被恢复，等等。</p><hr><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><h4 id="断点的设置-删除"><a href="#断点的设置-删除" class="headerlink" title="断点的设置/删除"></a>断点的设置/删除</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>tbreak</td><td>一次性断点，用完自动删除</td></tr><tr><td>rbreak <em>regex</em></td><td>正则断点，匹配满足条件的名字</td></tr><tr><td>break 5 if <em>condition</em></td><td>在第5行设置一个断点，满足condition时暂停程序</td></tr><tr><td>watch [-location] <em>expr</em></td><td>数据断点，当expr[-location:指向]的值发生改变时暂停程序</td></tr><tr><td>rwatch [-location] <em>expr</em></td><td>数据断点，expr被读取时暂停程序</td></tr><tr><td>awatch [-l] <em>expr</em></td><td>数据断点，expr被读取或写入时暂停程序</td></tr><tr><td>clear [filename:]function/linenum</td><td>删除函数或行号上的所有断点</td></tr><tr><td>delete</td><td>删除所有断点</td></tr></tbody></table><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>condition <em>bnum</em> <em>expr</em></td><td>在第bnum个断点上设置程序暂停条件expr</td></tr><tr><td>condition <em>bnum</em></td><td>取消第bnum个断点的程序暂停条件</td></tr><tr><td>ignore <em>bnum</em> <em>count</em></td><td>第bnum个断点被触发count次后暂停程序</td></tr></tbody></table><h4 id="断点命令commands…end"><a href="#断点命令commands…end" class="headerlink" title="断点命令commands…end:"></a>断点命令commands…end:</h4><p>遇到断点时，执行command和end之间的命令。<br>command和end分别用于标记断点命令表的开始和结束，而主体部分的命令将绑定在最近设置的断点上。例如：</p><pre><code>(gdb)break 7(gdb)commandssilentprintf &quot;x is %d\n&quot;, xcontinueend</code></pre><p>在编号为7的断点上设置了断点命令——slient(静默处理断点停止信息)、printf(输出x的值)、continue(继续运行程序)。</p><h4 id="断点的保存-恢复"><a href="#断点的保存-恢复" class="headerlink" title="断点的保存/恢复"></a>断点的保存/恢复</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>save breakpoints <em>filename</em></td><td>以命令的形式将所有断点保存到文件中</td></tr><tr><td>source <em>filename</em></td><td>执行filename文件的内容(这里是恢复断点)</td></tr></tbody></table><hr><h3 id="恢复运行与单步调试"><a href="#恢复运行与单步调试" class="headerlink" title="恢复运行与单步调试"></a>恢复运行与单步调试</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>continue<br> step [count]<br> next [count]<br> finish<br> until [count]</td><td>常规操作</td></tr><tr><td>until</td><td>继续运行程序，直到后一条指令被执行为止</td></tr><tr><td>stepi<br> si</td><td>执行一条机器指令，进入函数(如果有)</td></tr><tr><td>nexti<br> ni</td><td>执行一条机器指令，不进入函数</td></tr><tr><td>skip <em>file</em><br> skip <em>function</em></td><td>跳过不需要调试的文件/函数</td></tr><tr><td>skip enable/disable/delete [range]</td><td>启用/禁用/删除skips</td></tr></tbody></table><ul><li>until：这里的后一条指令是指，以内存地址值大小的”小于”作为指令的偏序关系，当前指令的最小上界。主要用于跳出循环。注意：如果看到执行完until的效果是，执行的语句反而”倒退”了，则很可能是编译器进行了机器指令位置上的调整(例如while改为了do-while)。</li></ul><hr><h3 id="录制与回放"><a href="#录制与回放" class="headerlink" title="录制与回放"></a>录制与回放</h3><p>将问题锁定在程序的某个区间后，如果需要反复逐条指令地运行这一段代码，可以采用gdb提供的录制回放功能。</p><p>gdb录制-回放模式: 在这个模式中，如果下一条指令已在记录中，gdb会以回放模式执行该指令(即并非真正运行该指令，而是从记录中读取与这条指令相关的信息，改变程序状态)。否则，gdb以录制模式执行该指令(将与之关联的信息保存到记录中)。多数情况下，回放模式支持逆行。以下是相关命令：</p><ul><li><p><strong>record <em>method</em></strong> 启用录制-回放模式，其中”<em>method</em>“可被以下参数代替：</p><ul><li><strong>full(default)</strong> 使用软件实现录制和回放，支持逆行。(随手测试100多条C++语句，产生大约3M的信息)</li><li><strong>btrace <em>format</em></strong><br>使用硬件支持录制状态。录制的内容不能保存到文件中;数据被保存在一个环状缓冲区——如果缓冲区已满，则会覆盖前面的数据。<em>format</em>可以被以下参数代替:<ul><li><strong>bts</strong> Branch trace store录制格式，储存每一个分支。</li><li><strong>pt</strong> Intel processor trace录制格式，储存之前经过压缩。</li></ul></li></ul><p>full方式不能用在non-stop mode和asynchronous execution mode。它们只能支持btrace方式。(?_?)</p></li><li><strong>record stop</strong> 删除所有记录，并退出录制-回放模式。</li><li><strong>record delete</strong> 抛弃前面录制的所有内容，从当前指令重新开始录制</li><li><strong>record goto <em>location</em></strong> 读取特定位置的记录。<em>location</em>可被以下参数代替：<ul><li><strong>begin/start</strong> 开始</li><li><strong>end</strong> 结束</li><li><strong>n</strong> 第n个指令</li></ul></li><li><strong>record save <em>filename</em></strong> 将记录存到filename文件中，默认为gdb_record.process_id。</li><li><strong>record restore <em>filename</em></strong> 从filename文件中读取记录。</li></ul><p>杂项：</p><ul><li><strong>set/show record full insn-number-max <em>limit</em></strong> 设置/查看最大记录指令数，<em>limit</em>可以为正整数或”unlimited”。</li><li><strong>set/show full stop-at-limit</strong> 指令数达到最大记录时，暂停程序</li><li><strong>set/show record btrace bts/pt buffer-size</strong> 设置btrace方式的缓冲区容量</li><li><strong>record instruction-history *</strong> 对录制的指令反汇编及相关操作</li></ul><h3 id="逆行"><a href="#逆行" class="headerlink" title="逆行"></a>逆行</h3><p>调试过程中的逆行，可以使程序逐步恢复到执行各指令之前的状态，包括寄存器、内存、输入输出设备等。一般情况下，在回放模式中可以逆行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set exec-direction forward/reverse</td><td>设置程序的运行方式为正向/逆向</td></tr><tr><td>reverse-<em>command</em></td><td>以逆向的方式执行<em>command</em>命令</td></tr></tbody></table><p>注意：上面的command可以被continue / step / stepi / next / nexti / finish任何一条命令替换。另外，如果exec-direction被设置为了逆向(reverse)，”<em>command</em>“和”reverse-<em>command</em>“的功能也被对换。</p><hr><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>backtrace full [n/-n] bt full [n/-n]</td><td>展示[最内/外n层的]栈回溯和局部变量</td></tr><tr><td>frame n f n</td><td>选择第n个函数栈</td></tr><tr><td>up/down n</td><td>进入上n级/下n级函数栈，n缺省为1</td></tr><tr><td>info frame info f</td><td>显示当前函数栈的详细信息，包括： 上/下级栈地址、源代码语言、函数参数地址、局部变量地址、上级函数栈指针sp、被保存的寄存器地址</td></tr><tr><td>info args/locals</td><td>显示函数参数/局部变量的信息 </td></tr></tbody></table><hr><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>disassemble /s</td><td>同时展示源代码和汇编代码</td></tr><tr><td>disassemble /r</td><td>同时展示机器代码和汇编代码</td></tr><tr><td>disassemble <em>begin</em>, <em>end</em></td><td>展示从begin到end的汇编代码</td></tr></tbody></table><hr><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul><li>类型检验/转换<ul><li><strong>ptype exp</strong> ：给定某个表达式，检验其运算结果的类型。如果exp是用户自定义类型，则输出该类型的源码; 如果是函数，则输出函数原型。</li><li><strong>p {type} addr</strong> ：以类型“type”输出地址“addr”的内容。比如：<code>p {int}0x618c20</code> 的含义是：将0x618c20处的内容“强制转换”为int，输出。</li></ul></li><li><p>数组访问</p><ul><li><strong>p *array@len</strong> ：表达式“*array@len”的结果是一个长度为len的数组，类型由array决定。其中“@”是一个二元运算符，左边是数组的第一个元素(必须在内存中)，右边是数组元素个数。</li><li><strong>p/x (type[])addr</strong> ：将addr强制转换为数组并输出。例如 <code>p (short[])0x12345678</code>的输出结果为$1 = {0x1234, 0x5678}。方括号内可以填入元素个数。</li><li><p>如果要访问的是指针数组中每个指针指向的对象，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set $i = 0</div><div class="line">p arr[$i++]-&gt;vp</div><div class="line">RET</div><div class="line">RET</div></pre></td></tr></table></figure><p>  其中RET是回车。</p></li></ul></li><li><p><strong>print/<em>format</em> val</strong>： 格式化输出val。其中format可以被以下字符代替：</p></li></ul><table><thead><tr><th>format</th><th>description</th></tr></thead><tbody><tr><td>x</td><td>int(hex)，十六进制整数</td></tr><tr><td>d</td><td>int(dec)，十进制整数</td></tr><tr><td>u</td><td>(unsigned)int，无符号整数</td></tr><tr><td>o</td><td>int(oct)，八进制整数</td></tr><tr><td>t</td><td>int(bin)，二进制整数</td></tr><tr><td>a</td><td>address，地址</td></tr><tr><td>c</td><td>char，字符</td></tr><tr><td>f</td><td>float，浮点数</td></tr><tr><td>s</td><td>string，尽可能转换为字符串</td></tr><tr><td>z</td><td>leading zero hex，十六进制整数，前面填充0</td></tr><tr><td>r</td><td>raw，原始形式</td></tr></tbody></table><ul><li><p><strong>x/<em>nfu</em> addr</strong>： 以一定的格式输出地址addr中的内容。</p><ul><li>n：repeat count，如果n是负数，则向前数-n个;     </li><li>f： format，和上述format含义相同; </li><li>u： unit size，可以是“b、h、w、g”中的一个，分别代表1、2、4、8个字节。</li></ul><p>执行完一条x addr命令以后，该结果临时保存在$_（美元符+1个下划线），addr的值临时保存在$__（美元符+2个下划线），方便下次取用。</p></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p>待填的坑：</p><ul><li>环境变量/工作目录/输入输出设备设置</li><li>远程调试正在运行的程序</li><li>多进程/多线程下的调试</li><li>catchpoint的使用</li><li>动态输出(dynamic printf)</li><li>静态探查点(static probe points)</li><li>信号</li><li>frame filter</li><li>动态连接程序的反汇编</li><li>数据类型探索(explore data)</li><li>convenience variables/functions</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学会了这个，调试速度马上提高1.005倍！点击阅读原文&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>真·「stack_overflow」</title>
    <link href="tangenta.github.io/2017/12/04/stack-overflow/"/>
    <id>tangenta.github.io/2017/12/04/stack-overflow/</id>
    <published>2017-12-04T12:09:00.000Z</published>
    <updated>2018-01-13T10:52:22.267Z</updated>
    
    <content type="html"><![CDATA[<p>前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的<a href="http://csapp.cs.cmu.edu/2e/home.html" target="_blank" rel="external">配套网站</a>和里面的<a href="http://csapp.cs.cmu.edu/2e/labs.html" target="_blank" rel="external">实验室</a>献上。。没有膝盖了，就点个赞吧。<br><a id="more"></a></p><hr><p>2018.01.13更新：初次实践，玩溢出的时候走了一些弯路：比如肉眼看内存状况，以及注入冗余代码等等。关于注入代码中的函数调用模拟：</p><blockquote><p>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">movl $0x1005b2b7,%eax</div><div class="line">pushl $0x8048dbe</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $0x38,%esp</div><div class="line">leave</div><div class="line">ret</div></pre></td></tr></table></figure></p></blockquote><p>这段说法存在问题。从代码分析可以发现，用于建立新函数栈的第3-5行可以和用于回收函数栈的第6行相互抵消。而ret的作用仅仅是pop返回地址+程序跳转，除了sp++之外，没有对栈结构造成其他影响。因此也没有“程序认为我们已经返回到了test中”这种说法。。</p><p>归根结底，还是对汇编指令与栈结构之间的联系理解得不够深刻。</p><hr><p>————原文分割线————</p><hr><p>栈溢出攻击：对于读入字符串时没有边界检查的程序，利用字符串不断写入信息覆盖返回值，使程序计数器跳转到指定位置，执行特定代码的行为。</p><p>下面是一个栗子(代码和图片都来自CSAPP)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> c;</div><div class="line"><span class="keyword">char</span> *dest = s;</div><div class="line"><span class="keyword">int</span> gotchar = <span class="number">0</span>; <span class="comment">/* Has at least one character been read? */</span></div><div class="line"><span class="keyword">while</span> ((c = getchar()) != ’\n’ &amp;&amp; c != EOF) &#123;</div><div class="line">*dest++ = c; <span class="comment">/* No bounds checking! */</span></div><div class="line">gotchar = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">*dest++ = ’\<span class="number">0</span>’; <span class="comment">/* Terminate string */</span></div><div class="line"><span class="keyword">if</span> (c == EOF &amp;&amp; !gotchar)</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* End of file or error */</span></div><div class="line"><span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Read input line and write it back */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></div><div class="line">gets(buf);</div><div class="line"><span class="built_in">puts</span>(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码经过gcc -m32编译过后产生一个在IA32处理器上运行的程序。<br>下图为程序执行到echo函数中的gets(buf)时的内存结构，地址数值从上往下递减。寄存器%ebp是echo的框架指针，并且白色矩形从上至下依次为：</p><ul><li>return address: 函数结束时的返回地址，即PC要跳转的地址;</li><li>saved %ebp: echo()调用者的框架指针;</li><li>saved %ebx: 具有callee-saved性质的寄存器保存的值;</li><li>buf[0]-buf[7]: 在栈上申请的空间，用于存放gets即将读入的字符串。<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></li></ul><p>栈溢出攻击要做的就是不断填入字符，一直延伸到返回地址并用“有效返回地址”覆盖它。这样函数在返回的时候PC就会跳转到我们想去的地方，执行想执行的命令，美滋滋。<br>好，今天就到此为止。</p><p><img src="/2017/12/04/stack-overflow/fakeEnd.png" width="100%" height="100%"></p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p><p>。。<br><br></p><p>到此为止是不可能到此的，这辈子都不可能到此为止，上面只是一个复习而已啦。下面开始进入正题：挽起袖子动手实现栈溢出。<br>原料：CSAPP实验室提供的bufbomb一枚，可以在Buffer Lab的Self-study Handout获得。<br>工具：gdb，objdump，gcc和脑子。</p><p>依题意得，该程序会调用下面的test函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</div><div class="line">val = getbuf();</div><div class="line"><span class="comment">/* Check for corrupted stack */</span></div><div class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</div><div class="line">validate(<span class="number">3</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">/* Buffer size for getbuf */</span></div><div class="line"> <span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">Gets(buf);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从命题人的角度分析，这个getbuf()是考察重点。鉴于它想用32个字节的数组容纳键盘输入的数据，看起来像个老实人，试探它一下：<br><img src="/2017/12/04/stack-overflow/typestring.png" width="80%" height="80%"><br>我写了34个字符还能让我走，果然是个老实人，可以欺负。</p><p>现在可以定一个小目标：通过外部输入，让test函数执行它的第二个条件分支语句<strong>else if (val == cookie) {…</strong></p><p>分析一下，要让首先要让val==cookie成立。(考虑到这是一个assignment，当然要有机制来防止抄袭，这里cookie就是一个根据用户名生成的一个值。这里我的用户名使用的是bovik，对应的cookie值是0x1005b2b7)<br>就是说，要把val改为0x1005b2b7。又观察到val = getfuf()，所以我们只需要把getbuf()的返回值从1改为0x1005b2b7就好了。</p><p>具体的流程是，取得程序的控制权-&gt;执行特定的机器指令-&gt;归还控制权。</p><p>首先，掏出工具看看getbuf的汇编代码：</p><blockquote><p><code>$ objdump -d bufbomb | grep -20 &quot;&lt;getbuf&gt;&quot;</code><br><img src="/2017/12/04/stack-overflow/getbuf.png" width="100%" height="100%"><br>可以看到进入函数以后，在栈分配了0x38字节的空间，其中0x28是用来放准备从键盘读入的字符(0x20)和上一级的框架指针位置ebp(0x8);最低的0x8用来存Gets的参数;中间空了的0x8不知道拿来干嘛的。。<br>值得一提的是，这个%eax存放的0x1就是目标，在注入的机器指令中要修改它的值。</p></blockquote><p>然后侦查一波，检查getbuf调用时的内存状况：</p><blockquote><p><code>$ gdb ./bufbomb</code>      #  进入gdb<br><code>(gdb) b getbuf</code>        #  在getbuf设置断点<br><code>(gdb) r -u bovik</code>    #  执行，这里的bovik就是用户名<br><img src="/2017/12/04/stack-overflow/bgetbuf.png" width="100%" height="100%"><br>cookie值：0x1005b2b7<br><img src="/2017/12/04/stack-overflow/stopAtGetbuf.png" width="100%" height="100%"><br>好，程序已经停在了断点处，可以开始观察了：<br><code>(gdb) info register</code> #  查看寄存器情况<br><img src="/2017/12/04/stack-overflow/infoRegis1.png" width="100%" height="100%"><br>主要关注ebp和esp。0xb0-0x78 == 0x38，和分析的一致，稳。<br>最关键的部分来了：内存现场<br><code>(gdb) x/80bx $esp</code>   #  以16进制查看从$esp开始，80个字节的内存情况<br><img src="/2017/12/04/stack-overflow/initMem.png" width="100%" height="100%"><br>白色高亮部分左边的0x556835b0就是当前框架指针ebp的值。<br>如果不出意外，这里包含了上级框架指针%ebp地址和返回地址。</p></blockquote><p>要取得程序的控制权，先要覆盖返回地址。要覆盖返回地址，就必须知道返回地址在哪。那我们先看看正常的返回地址长啥样，看test函数中调用getbuf的下一行：</p><blockquote><p><code>(gdb） disas test</code>    #  查看test的汇编代码<br><img src="/2017/12/04/stack-overflow/retAddr.png" width="100%" height="100%"><br>getbuf函数调用完之后，程序应该返回0x08048dbe;跟我念，08,04,8d,be。<br>趁着还没忘记，赶紧回到上一张图高亮部分，从后往前看：08..04..8d..be！！！果然没错，就是要覆盖掉这里！<br>(至于为什么要倒过来，这可能就是little endian的哲学了吧。)</p></blockquote><p>那输入要从哪开始呢？前面getbuf的汇编告诉我们，字符数组从-0x28(%ebp)开始，可以用gdb里面的计算器算一算：</p><blockquote><p><code>(gdb) p $ebp-0x28</code><br><code>$1 = (void *) 0x55683588 &lt;_reserved+1037704&gt;</code><br><img src="/2017/12/04/stack-overflow/stringAddr.png" width="100%" height="100%"><br>就是说，要填满32个字节之后，还要再填16个字节才能覆盖返回地址。</p></blockquote><p>下面就面临一个问题了：覆盖了返回地址，去哪？<br><br><br><br><br><br><br><br></p><p>当然是去能够执行我给它的机器指令的地方啊！<br>显然，能够注入的指令的地址位置在0x55683588+，那跳转到哪比较合适呢？这时有两个选择：</p><ul><li>一个是buf[]数组里面，没有副作用，不会腐蚀前一个函数的栈结构，但是能写入的机器指令也很有限：总不能越过刚刚覆盖完的返回地址吧(回到过去杀掉自己的感觉?_?)。</li><li>另一个是“覆盖返回地址位置”之后，即0x556835b8+，不过这样很可能腐蚀前一个函数的栈结构，把别人家捣烂了还想不被发现，有点难度。而且别忘了test函数还有个门卫：<strong>volatile int local = uniqueval();</strong>，要是碰到了这个东西就更麻烦了(当然也不是不可以，用注入的机器指令恢复它的值就行。这就要看能不能摸透uniqueval了)。</li></ul><p>所以，说了这么多，还是尽量选第一个吧。毕竟我们的目标比较简单，目测注入代码也比较少。</p><blockquote><p>把这一坨东西丢进我“30行的cpp程序”中，去掉没用的信息(没错就是这么懒)<br><code>0x55683588 &lt;_reserved+1037704&gt;:    0x00    0x00    0x00    0x00    0x8d    0xe4    0xe2    0xf7</code><br><code>0x55683590 &lt;_reserved+1037712&gt;:    0x00    0x00    0x00    0x00    0xa8    0x8d    0x04    0x08</code><br><code>0x55683598 &lt;_reserved+1037720&gt;:    0x1f    0x6b    0x00    0x00    0xfc    0x1d    0xfb    0xf7</code><br><code>0x556835a0 &lt;_reserved+1037728&gt;:    0xe0    0x35    0x68    0x55    0xee    0x42    0xef    0xf7</code><br><code>0x556835a8 &lt;_reserved+1037736&gt;:    0x60    0x1d    0xfb    0xf7    0x7e    0xa5    0x04    0x08</code><br><code>0x556835b0 &lt;_reserved+1037744&gt;:    0xe0    0x35    0x68    0x55    0xbe    0x8d    0x04    0x08</code><br>得到<br><code>00 00 00 00 8d e4 e2 f7</code><br><code>00 00 00 00 a8 8d 04 08</code><br><code>1f 6b 00 00 fc 1d fb f7</code><br><code>e0 35 68 55 ee 42 ef f7</code><br><code>60 1d fb f7 7e a5 04 08</code><br><code>e0 35 68 55 be 8d 04 08</code><br>将最后一行修改为”e0 35 68 55 <strong>88 35 68 55</strong>“，最后转成字符输出到文件，执行程序时重定向一下(因为有些字符是键盘上没有的)，就可以跳转到指定位置啦。<br>(在正常情况下这段字符不应含有0x00，因为一般的gets在判断到有0x00对应的字符时，应该是会终止输入的。这里它没有这个限制)</p></blockquote><p>接下来就要写我们想执行的机器代码了，有些人一上来就拿起本IA32机器指令手册一条一条对照，想想就很激动。<br>我开始也是这么想的，结果发现完全可以：手工写汇编code.s + gcc -c code.s + objdump -d code.o，我倒。</p><p>手写汇编代码，主要包含的要点：</p><ul><li>修改返回值是主要目的：<br><strong>movl $0x1005b2b7,%eax</strong></li><li><p>模拟函数调用：<br><strong>pushl $0x8048dbe</strong><br><strong>pushl %ebp</strong><br><strong>movl %esp,%ebp</strong><br><strong>subl $0x38,%esp</strong><br>…<br>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br>在模拟之前，首先要理解函数的调用过程：</p><ol><li><code>call，它的动作是push-and-jump(返回地址压栈，PC跳转);</code></li><li><code>push %ebp和mov %esp,%ebp(框架和栈指针合并);</code></li><li><code>sub %esp(为该函数分配栈空间，以便存放局部变量);</code></li></ol><p>由于我们第一步是通过hack了ret来实现的jump，所以并没有完全地按照call的动作，为了完全模拟，需要地址压栈，因此就不难理解第一行的<br><strong>pushl $0x8048dbe</strong>  (test中调用getbuf的下一行的地址)。</p></li><li>把控制权交回给test：<br><strong>leave</strong><br><strong>ret</strong><br>和getbuf函数的结束操作一样就行了:) 这里就顺便复习下leave和ret吧：<ol><li><code>leave是mov %ebp,%esp和pop %ebp(合并框架和栈指针，ebp回退到上一级函数状态)</code></li><li><code>ret是pop-and-jump(返回地址出栈，PC跳转)</code></li></ol></li></ul><p>最后的机器代码长这样：<br><img src="/2017/12/04/stack-overflow/machineCode.png" width="100%" height="100%"><br>从字符输入的起始位置替换：</p><pre><code>68 be 8d 04 08 55 89 e583 ec 38 b8 b7 b2 05 10c9 c3 00 00 fc 1d fb f7e0 35 68 55 ee 42 ef f760 1d fb f7 7e a5 04 08e0 35 68 55 88 35 68 55</code></pre><p>将这段机器指令用./hex2raw转换存到string.txt,<br><code>$ ./bufbomb -u bovik &lt; string.txt</code><br><img src="/2017/12/04/stack-overflow/finish1.png" width="100%" height="100%"></p><p>大功告成。</p><p><br><br><br><br><br><br><br><br><br></p><p>但是，还没有结束。<br>我们刚刚完成的是对一个“每次运行都使用相同栈地址”的演示程序的攻击。然鹅，在实际上，绝大多数的程序都会使用ASLR(address-space layout randomization)来作为保护。ASLR中的技术之一：栈随机化(stack randomization)能够有效防止栈溢出攻击。其主要表现为：在不同的时间运行同一段代码，里面使用到的栈地址都很可能不同。这可以通过”每次在程序执行前，在栈上分配一段随机大小的空间”来实现。</p><p>这样对于攻击者来说，在覆盖返回地址的时候不得不思考一个问题：-跳转到哪？-当然是能够执行我给它的机器指令的地方啊。-就是哪个地方？ -好像还真不好说，每次都不一样。</p><p>一般来说，考虑到程序的空间使用效率，栈随机化分配的空间不会太大。这时，就可以祭出nop-sled了：对于栈随机化程度有限，没有缓冲边界检查的程序，非常好用。那nop-sled到底该怎么用呢？在动手之前，我也有这个疑惑。<br>以下是我实际操作过程中的一些思考：<br>矛盾点在于，<strong>跳转的地址没办法确定为一个值(由于栈随机化)，而输入的攻击字符串却要求是固定的一个值。</strong>覆盖返回地址作为栈溢出攻击的第一步，如果不确定这个值就没法执行注入代码，汇编写得再牛也白搭。</p><p>尝试多次执行同一个程序的同一个函数，可以发现栈指针和框架指针的地址都在一定的范围内波动，如下图所示：<br><img src="/2017/12/04/stack-overflow/stack-randomization.png" width="50%" height="50%"><br>可以看到存放数据的buffer的地址也在一定范围内波动。</p><p>就是说<strong>跳转的地址要选一个定值，并且无论这个值处于栈结构的哪个位置，最终都能够执行注入的机器指令。</strong></p><p>这就容易想到该怎么用nop-sled了：把注入代码存放在buffer的末端，只要找到一个共用地址，并用nop作为背景填充(保证共用地址和注入代码地址之间都是nop)，程序跳转到共用地址后开始执行nop，滑落到注入代码部分，攻击就能够实现。如下图所示：<br><img src="/2017/12/04/stack-overflow/nop-sled.png" width="50%" height="50%"><br>当然这个共用地址也可以划到buffer外面去，不过这样会腐蚀更多的内容，恢复的难度也会相应增加。</p><p>下面简单提一提破坏恢复难度。显然，覆盖返回地址，同时也意味着腐蚀了返回地址之前的信息，再次搬出前面的图：<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></p><ul><li>saved %ebp被覆盖：这导致上一级框架指针位置信息丢失。如果不考虑这一点，必然导致栈结构腐蚀，很可能导致段错误。</li><li>saved %ebx或其他callee-saved的寄存器保存的值被覆盖：如果说上一级%ebp的信息还能通过%esp计算找回来，这种类型的信息一旦丢失，几乎无从找回，或者说找回的难度直接受”原程序计算出该值的方式“影响。要想恢复，汇编功底需要极其深厚。</li></ul><p>最后，总结一下栈溢出攻击的步骤：</p><ol><li>试探：看看有没有边界检查</li><li>确定覆盖点：在汇编中找到原返回地址，并和正常执行时的内存比对</li><li>分析注入代码存放位置：考虑注入代码长度、结构腐蚀的可恢复性</li><li>手写汇编代码：爱干啥干啥，如果要做到不留痕迹，恢复破坏的数据</li><li>汇编为机器指令，生成字符串：十六进制数字转字符</li><li>fire！</li></ol><p>最后的最后，要想避免自己的程序被别人用这种方式攻击，最简单的方法当然就是做好边界检查，让你写入32个字符就只能写入32个，多半个都不行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/home.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配套网站&lt;/a&gt;和里面的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/labs.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验室&lt;/a&gt;献上。。没有膝盖了，就点个赞吧。&lt;br&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="栈溢出" scheme="tangenta.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++读文件操作暗礁</title>
    <link href="tangenta.github.io/2017/10/26/fstream-trap/"/>
    <id>tangenta.github.io/2017/10/26/fstream-trap/</id>
    <published>2017-10-26T13:16:00.000Z</published>
    <updated>2018-01-13T10:51:37.062Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，先出一道题：<br>给定一个<strong>行数=3</strong>的文本文件，如何把每行的内容读出来存到std::vector<string>里面？<br><a id="more"></a></string></p><p>如果你的答案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">fstream <span class="title">in</span><span class="params">(<span class="string">"text"</span>)</span></span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line"><span class="built_in">string</span> buf;</div><div class="line"><span class="keyword">while</span>(in) &#123;</div><div class="line">  getline(in, buf);</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么我掐指一算：<br>你最近是不是感觉到你写的文件读写程序，行为有点怪异？<br>是不是忍不住发出惊叹“明明读完了啊，怎么多一行“？<br>是不是把fstream里面有关good/eof/fail/bad的文档全看了一遍，还是找不到问题在哪？<br>是不是才爬个5楼，就觉得胸闷气短…<br>咳，回到正题：如果在最后加一句</p><pre><code>cout&lt;&lt;v.size()&lt;&lt;&quot;\n&quot;;</code></pre><p>发现结果是4。分析一下原因：在in&gt;&gt;buf读取文件最后一行的时候，状态为goodbit，v.push_back正常读入最后一行;再次判断循环条件，由于goodbit，进入循环;这时in&gt;&gt;tmp就开始出问题了，它读到了文件结束符eof。然而我们的buf可不管，读不到东西也push_back，这就造成size比行数大1的结果。<br>总结起来一句话就是：<strong>“从文件读取到缓冲”和”从缓冲输入到容器”之间没有空隙，即无条件连接。</strong><br>显然，while的条件判断起作用的时机晚了。一个解决方案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;<span class="comment">//solution1</span></div><div class="line">  getline(in, buf);</div><div class="line">  <span class="keyword">if</span> (!in) <span class="keyword">break</span>;</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其等价于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(getline(in, buf)) &#123;<span class="comment">//solution2</span></div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二个解决方案也是C++中的惯用法(idiom)，更为简洁、美观。</p><pre><code>return;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，先出一道题：&lt;br&gt;给定一个&lt;strong&gt;行数=3&lt;/strong&gt;的文本文件，如何把每行的内容读出来存到std::vector&lt;string&gt;里面？&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>邂逅异或链表</title>
    <link href="tangenta.github.io/2017/10/22/xorLinkedList/"/>
    <id>tangenta.github.io/2017/10/22/xorLinkedList/</id>
    <published>2017-10-22T13:39:00.000Z</published>
    <updated>2018-01-13T10:51:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。</p><a id="more"></a><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>异或链表的原理是，表中的每个节点跟单链表一样，都有俩区域: 数据域和指针域。这个指针域就厉害了，存的不是别人，而是它前后节点地址的异或。得益于异或运算的性质，任何时候只需要知道链表中相邻的两个节点地址，就可以访问其中的每一个节点。以前只听过异或运算能用来实现inplace swap(不需要额外的空间就可以交换两个变量)，没想到还能应用到链表中。</p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>看起来很简单嘛，内嵌一个节点类，复制控制函数压死，再上容器四大护法增删改查，一切都很顺利……嗯？这段怎么这么deja vu？定睛一看，这几段都有遍历操作，而每次遍历都用到两个节点指针，一前一后一个while，内部再一个判断一个break。想起scott meyers教导我们，代码复制不可取。今天复制一段代码，明天就会复制一个文件，后天……跑题了，总之作为一个有理想的青年，代码复制要不得。想到这里，我这暴脾气就上来了，一顿操作从删掉重写到发朋友圈，丝毫不拖泥带水，思考时被我拔掉的头发也不算特别多。这个是效果：</p><p>修改前:<br><img src="/2017/10/22/xorLinkedList/2017-10-22-1.png" width="50%" height="50%"></p><p>修改后：<br><img src="/2017/10/22/xorLinkedList/2017-10-22-2.png" width="50%" height="50%"></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-3.png" width="100%" height="100%"></p><p>将判断条件、迭代调整、返回值做成函数调用形式，达到用模板参数传递”功能“(函数指针、函数对象或lambda表达式)的目的。简单说就是从外部把功能嵌入函数体中。</p><p>一个traverse函数打天下 =_=</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>敲定最后一个lambda表达式，好不容易松了口气，正欣赏着”成果”，不知道《C++ template》的哪一个混蛋作者在我脑子里喊了句”code bloat”。</p><p>。。。</p><p>。。。</p><p>我、lambda表达式们大眼瞪小眼，这时我才发现一个个的lambda(s?)，每个类型都不相同，这意味着几乎每次使用到traverse()都要实例化，我仿佛已经看到了目标文件的臃肿。再一细看，还把traverse写成了public。典型滥用模板的例子，哎。</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>我不甘心啊！伴随着更多头发的飘落，”遍历“这个词终于让我联想到了”迭代器“。是啊，为什么不搞一个迭代器呢？<br>for(List<t>::iterator i = v.begin(); i != v.end(); ++i) {…}，<br>多么优雅。但是迭代器内部的数据一般只有一个指针，而异或链表的遍历必须由两个指针贴着走。那一个迭代器包含两个指针行不行呢？开始尝试：</t></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-4.png" width="100%" height="100%"><br>解引用操作和指针操作都取ptr2，{ptr1 = 0; ptr2 = head}对应begin，{ptr1 = tail, ptr2 = 0}对应end，没毛病。</p><p>(中间踩了点小坑，这里省略一万字，”explicit你都干了些什么”、”包含编译模型之凝视”、”const成员函数之谜”、”多余&amp;引发的运行时血案”之类的不再细叙)</p><p>最终效果如下：<br>(这是获得第pos-1个节点和第pos个节点指针的具体实现)<br><img src="/2017/10/22/xorLinkedList/2017-10-22-5.png" width="100%" height="100%"><br>很明显，无论是易读性、可维护性都提高了不少。</p><p><a href="https://gitee.com/tangenta/XorList.git" target="_blank" rel="external">XorList源码</a></p><p>虽然简陋版迭代器是写出来了，但不知道它和stl算法的结合情况如何。哪天出乱子了我再收拾它去。</p><pre><code>return (待续||不续);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。&lt;/p&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
      <category term="stl" scheme="tangenta.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="tangenta.github.io/2017/09/28/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>tangenta.github.io/2017/09/28/git学习笔记/</id>
    <published>2017-09-28T07:58:00.000Z</published>
    <updated>2018-01-13T10:50:30.024Z</updated>
    
    <content type="html"><![CDATA[<p>用作记录，方便查阅<br><a id="more"></a></p><h2 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git init</td><td>在当前目录初始化仓库</td></tr></tbody></table><h2 id="提交-上传文件"><a href="#提交-上传文件" class="headerlink" title="提交/上传文件"></a>提交/上传文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git add fileName</td><td>将工作区文件添加到暂存区</td></tr><tr><td> $ git commit -m “some comment”</td><td>将暂存区文件添加到版本库</td></tr></tbody></table><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git rm fileName</td><td>删掉暂存区的文件</td></tr></tbody></table><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git status</td><td>显示仓库当前状态</td></tr><tr><td> $ git diff fileName</td><td>显示工作区和版本库的差异</td></tr><tr><td> $ git log [–pretty=oneline] [–graph] [–abbrev-commit]</td><td>显示版本库内的commit历史记录 [以单行的形式显示][显示分支图]</td></tr><tr><td> $ git reflog</td><td>显示版本变更的历史命令</td></tr><tr><td> $ git branch</td><td>查看当前所在的分支</td></tr><tr><td> $ git stash list</td><td>查看被储存的工作区列表</td></tr><tr><td> $ git remote -v</td><td>查看远程库的[详细]信息</td></tr><tr><td> $ git tag</td><td>查看所有标签</td></tr><tr><td> $ git show <tagname></tagname></td><td>查看某一个标签的信息</td></tr></tbody></table><h2 id="版本设置"><a href="#版本设置" class="headerlink" title="版本设置"></a>版本设置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git reset –hard HEAD^</td><td>HEAD为当前版本，每一个”^”代表上一个版本。HEAD~n代表上n个版本</td></tr><tr><td> $ git reset –hard commitId</td><td>将当前版本设置到版本号为“commitId”的版本</td></tr></tbody></table><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout – fileName</td><td>使工作区文件撤销到(暂存区或版本库)的状态</td></tr><tr><td> $ git reset HEAD fileName</td><td>使暂存区的文件撤销到版本库的状态</td></tr></tbody></table><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ ssh-keygen -t rsa -C “email@example.com”</td><td>获取ssh key</td></tr><tr><td> $ git remote add origin git@serverName:path/repoName.git</td><td>关联远程库</td></tr><tr><td> $ git remote rm origin</td><td>删除origin远程库</td></tr><tr><td> $ git push -u origin master</td><td>第一次推送master分支的所有内容</td></tr><tr><td> $ git push origin master</td><td>推送最新修改</td></tr><tr><td> $ git clone git@serverName:path/repoName.git</td><td>克隆远程仓库到本地</td></tr><tr><td> $ git push origin master</td><td>把本地的master分支推送到远程origin分支上</td></tr></tbody></table><h2 id="创建-合并-删除分支"><a href="#创建-合并-删除分支" class="headerlink" title="创建/合并/删除分支"></a>创建/合并/删除分支</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout -b dev origin/dev</td><td>创建一个dev分支，并关联远程的orgin/dev分支</td></tr><tr><td> $ git branch –set-upstream dev origin/dev</td><td>设置本地dev于远程仓库origin/dev关联</td></tr><tr><td> $ git pull</td><td>将本地文件与远程仓库同步</td></tr><tr><td> $ git checkout -b dev</td><td>创建并切换到分支dev</td></tr><tr><td> $ git branch dev</td><td>创建分支dev</td></tr><tr><td> $ git checkout dev</td><td>切换到分支dev</td></tr><tr><td> $ git merge dev</td><td>把分支dev合并到当前分支</td></tr><tr><td> $ git branch -d dev</td><td>删除已被合并的分支dev</td></tr><tr><td> $ git branch -D dev</td><td>强制删除未合并的分支dev</td></tr><tr><td> $ git merge –no-ff -m “some comments” dev</td><td>以创建一个commit的方式合并dev分支</td></tr></tbody></table><h2 id="工作区临时储存-恢复"><a href="#工作区临时储存-恢复" class="headerlink" title="工作区临时储存/恢复"></a>工作区临时储存/恢复</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git stash</td><td>储存当前工作区状态，并清空</td></tr><tr><td> $ git stash apply [stash@{n}]</td><td>恢复上一个被储存的工作区 [第n个储存的工作区]</td></tr><tr><td> $ git stash drop</td><td>删除stash list</td></tr><tr><td> $ git stash pop</td><td>恢复工作区，并删除stash list</td></tr></tbody></table><h2 id="标签创建-删除"><a href="#标签创建-删除" class="headerlink" title="标签创建/删除"></a>标签创建/删除</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git tag v1.0 [commit Id]</td><td>为当前最新的提交创建名为v1.0的标签 [对给定提交id创建]</td></tr><tr><td> $ git tag -a v0.1 -m “some comments” commitId</td><td>-a指定名字，-m指定说明文字</td></tr><tr><td> $ git tag -d v0.1</td><td>删除名为v0.1的标签</td></tr><tr><td> $ git push origin <tagname></tagname></td><td>将tagName标签推送到远程</td></tr><tr><td> $ git push origin –tags</td><td>将所有未推送的标签推送到远程</td></tr><tr><td> $ git push origin :refs/tags/v0.9</td><td>删除远程名为v0.9的标签</td></tr></tbody></table><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git config –global color.ui true</td><td>显示颜色</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用作记录，方便查阅&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
      <category term="git" scheme="tangenta.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GDB常用命令汇总</title>
    <link href="tangenta.github.io/2017/09/27/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>tangenta.github.io/2017/09/27/GDB常用命令汇总/</id>
    <published>2017-09-27T12:36:00.000Z</published>
    <updated>2018-01-13T10:50:06.856Z</updated>
    
    <content type="html"><![CDATA[<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><title>GDB常用命令汇总</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="generator" content="Org-mode"><style type="text/css"> <!--/*--><![CDATA[/*><!--*/  .title  { text-align: center; }  .todo   { font-family: monospace; color: red; }  .done   { color: green; }  .tag    { background-color: #eee; font-family: monospace;            padding: 2px; font-size: 80%; font-weight: normal; }  .timestamp { color: #bebebe; }  .timestamp-kwd { color: #5f9ea0; }  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }  .center { margin-left: auto; margin-right: auto; text-align: center; }  .underline { text-decoration: underline; }  #postamble p, #preamble p { font-size: 90%; margin: .2em; }  p.verse { margin-left: 3%; }  pre {    border: 1px solid #ccc;    box-shadow: 3px 3px 3px #eee;    padding: 8pt;    font-family: monospace;    overflow: auto;    margin: 1.2em;  }  pre.src {    position: relative;    overflow: visible;    padding-top: 1.2em;  }  pre.src:before {    display: none;    position: absolute;    background-color: white;    top: -10px;    right: 10px;    padding: 3px;    border: 1px solid black;  }  pre.src:hover:before { display: inline;}  pre.src-sh:before    { content: 'sh'; }  pre.src-bash:before  { content: 'sh'; }  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }  pre.src-R:before     { content: 'R'; }  pre.src-perl:before  { content: 'Perl'; }  pre.src-java:before  { content: 'Java'; }  pre.src-sql:before   { content: 'SQL'; }  table { border-collapse:collapse; }  caption.t-above { caption-side: top; }  caption.t-bottom { caption-side: bottom; }  td, th { vertical-align:top;  }  th.right  { text-align: center;  }  th.left   { text-align: center;   }  th.center { text-align: center; }  td.right  { text-align: right;  }  td.left   { text-align: left;   }  td.center { text-align: center; }  dt { font-weight: bold; }  .footpara:nth-child(2) { display: inline; }  .footpara { display: block; }  .footdef  { margin-bottom: 1em; }  .figure { padding: 1em; }  .figure p { text-align: center; }  .inlinetask {    padding: 10px;    border: 2px solid gray;    margin: 10px;    background: #ffffcc;  }  #org-div-home-and-up   { text-align: right; font-size: 70%; white-space: nowrap; }  textarea { overflow-x: auto; }  .linenr { font-size: smaller }  .code-highlighted { background-color: #ffff00; }  .org-info-js_info-navigation { border-style: none; }  #org-info-js_console-label    { font-size: 10px; font-weight: bold; white-space: nowrap; }  .org-info-js_search-highlight    { background-color: #ffff00; color: #000000; font-weight: bold; }  /*]]>*/--></style><script type="text/javascript">/*@licstart  The following is the entire license notice for theJavaScript code in this tag.Copyright (C) 2012-2013 Free Software Foundation, Inc.The JavaScript code in this tag is free software: you canredistribute it and/or modify it under the terms of the GNUGeneral Public License (GNU GPL) as published by the Free SoftwareFoundation, either version 3 of the License, or (at your option)any later version.  The code is distributed WITHOUT ANY WARRANTY;without even the implied warranty of MERCHANTABILITY or FITNESSFOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.As additional permission under GNU GPL version 3 section 7, youmay distribute non-source (e.g., minimized or compacted) forms ofthat code without the copy of the GNU GPL normally required bysection 4, provided you include this license notice and a URLthrough which recipients can access the Corresponding Source.@licend  The above is the entire license noticefor the JavaScript code in this tag.*/<!--/*--><![CDATA[/*><!--*/ function CodeHighlightOn(elem, id) {   var target = document.getElementById(id);   if(null != target) {     elem.cacheClassElem = elem.className;     elem.cacheClassTarget = target.className;     target.className = "code-highlighted";     elem.className   = "code-highlighted";   } } function CodeHighlightOff(elem, id) {   var target = document.getElementById(id);   if(elem.cacheClassElem)     elem.className = elem.cacheClassElem;   if(elem.cacheClassTarget)     target.className = elem.cacheClassTarget; }/*]]>*///--></script></head><body><p>用作记录，方便查阅</p><a id="more"></a><div id="content"><div id="table-of-contents"><h1>Table of Contents</h1><div id="text-table-of-contents"><ul><li><a href="#sec-1">1. Starting</a></li><li><a href="#sec-2">2. Running and stopping</a></li><li><a href="#sec-3">3. Breakpoints</a></li><li><a href="#sec-4">4. Execution</a></li><li><a href="#sec-5">5. Examining code</a></li><li><a href="#sec-6">6. Examining data</a></li><li><a href="#sec-7">7. Useful information</a></li></ul></div></div><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">Command</td><td class="left">Effect</td></tr></tbody></table><div id="outline-container-sec-1" class="outline-1"><h1 id="sec-1"><span class="section-number-1">1</span> Starting</h1><div class="outline-text-1" id="text-1"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">gdb</td><td class="left">&#xa0;</td></tr><tr><td class="left">gdb &lt;file&gt;</td><td class="left">&#xa0;</td></tr></tbody></table></div></div><div id="outline-container-sec-2" class="outline-1"><h1 id="sec-2"><span class="section-number-1">2</span> Running and stopping</h1><div class="outline-text-1" id="text-2"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">run</td><td class="left">Run program</td></tr><tr><td class="left">run 1 2 3</td><td class="left">Run program with command-line arguments 1 2 3</td></tr><tr><td class="left">kill</td><td class="left">Stop the program</td></tr><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">Ctrl-d</td><td class="left">Exit gdb</td></tr></tbody></table><p>Note: Ctrl-C does not exit from gdb, but halts the currentgdb command</p></div></div><div id="outline-container-sec-3" class="outline-1"><h1 id="sec-3"><span class="section-number-1">3</span> Breakpoints</h1><div class="outline-text-1" id="text-3"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">break sum</td><td class="left">Set breakpoint at the entry to function sum</td></tr><tr><td class="left">break *0x80483c3</td><td class="left">Set breakpoint at address 0x80483c3</td></tr><tr><td class="left">delete 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">disable 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">enable 1</td><td class="left">Enable breakpoint 1</td></tr><tr><td class="left">delete</td><td class="left">Delete all breakpoints</td></tr><tr><td class="left">clear sum</td><td class="left">clear sum</td></tr></tbody></table></div></div><div id="outline-container-sec-4" class="outline-1"><h1 id="sec-4"><span class="section-number-1">4</span> Execution</h1><div class="outline-text-1" id="text-4"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">stepi</td><td class="left">Execute one instruction</td></tr><tr><td class="left">stepi 4</td><td class="left">Execute four instructions</td></tr><tr><td class="left">nexti</td><td class="left">Like stepi, but proceed through function calls without stopping</td></tr><tr><td class="left">step</td><td class="left">Execute one C statement</td></tr><tr><td class="left">continue</td><td class="left">Resume execution until the next breakpoint</td></tr><tr><td class="left">until 3</td><td class="left">Continue executing until program hits breakpoint 3</td></tr><tr><td class="left">finish</td><td class="left">Resume execution until current function returns</td></tr><tr><td class="left">call sum(1,2)</td><td class="left">Call sum(1,2) and print return value</td></tr></tbody></table></div></div><div id="outline-container-sec-5" class="outline-1"><h1 id="sec-5"><span class="section-number-1">5</span> Examining code</h1><div class="outline-text-1" id="text-5"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">disas</td><td class="left">Disassemble current function</td></tr><tr><td class="left">disas sum</td><td class="left">Disassemble function sum</td></tr><tr><td class="left">disas 0x80483b7</td><td class="left">Disassemble function around 0x80483b7</td></tr><tr><td class="left">disas 0x80483b7 0x80483c7</td><td class="left">Disassemble code within specified address range</td></tr><tr><td class="left">print /x $rip</td><td class="left">Print program counter in hex</td></tr><tr><td class="left">print /d $rip</td><td class="left">Print program counter in decimal</td></tr><tr><td class="left">print /t $rip</td><td class="left">Print program counter in binary</td></tr></tbody></table></div></div><div id="outline-container-sec-6" class="outline-1"><h1 id="sec-6"><span class="section-number-1">6</span> Examining data</h1><div class="outline-text-1" id="text-6"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print /d $rax</td><td class="left">Print contents of %rax in decimal</td></tr><tr><td class="left">print /x $rax</td><td class="left">Print contents of %rax in hex</td></tr><tr><td class="left">print /t $rax</td><td class="left">Print contents of %rax in binary</td></tr><tr><td class="left">print /d (int)$rax</td><td class="left">Print contents of %rax in decimal after sign-extending lower 32-bits.</td></tr></tbody></table><p>You need this to print 32-bit, negative numbers stored in the lower 32 bits of %rax.For example, if the lower 32-bits of %rax store 0xffffffff, you will see: </p><pre class="example">(gdb) print $rax$1 = 4294967295(gdb) print (int)$rax$2 = -1</pre><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print 0x100</td><td class="left">Print decimal representation of 0x100</td></tr><tr><td class="left">print /x 555</td><td class="left">Print hex representation of 555</td></tr><tr><td class="left">print /x ($rsp+8)</td><td class="left">Print (contents of %rsp) + 8 in hex</td></tr><tr><td class="left">print *(int *) 0xbffff890</td><td class="left">Print integer at address 0xbffff890</td></tr><tr><td class="left">print *(int *) ($rsp+8)</td><td class="left">Print integer at address %rsp + 8</td></tr><tr><td class="left">print (char *) 0xbfff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/w   0xbffff890</td><td class="left">Examine (4-byte) word starting at address 0xbffff890</td></tr><tr><td class="left">x/w   $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp</td></tr><tr><td class="left">x/wd  $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/2w  $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp</td></tr><tr><td class="left">x/2wd $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/g   $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp.</td></tr><tr><td class="left">x/gd  $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/a   $rsp</td><td class="left">Examine address in $rsp. Print as offset from previous global symbol.</td></tr><tr><td class="left">x/s   0xbffff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/20b sum</td><td class="left">Examine first 20 opcode bytes of function sum</td></tr><tr><td class="left">x/10i sum</td><td class="left">Examine first 10 instructions of function sum</td></tr></tbody></table><p>(Note: the format string for the `x' command has the general form x/[NUM][SIZE][FORMAT] where</p><pre class="example">NUM  = number of objects to display.SIZE = size of each object (b=byte, h=half-word, w=word, g=giant (quad-word))FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)</pre><p>  If you don't specify SIZE or FORMAT, either a default value, or the last  value you specified in a previous `print' or `x' command is used.)</p></div></div><div id="outline-container-sec-7" class="outline-1"><h1 id="sec-7"><span class="section-number-1">7</span> Useful information</h1><div class="outline-text-1" id="text-7"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">backtrace</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">where</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">info program</td><td class="left">Print current status of the program)</td></tr><tr><td class="left">info functions</td><td class="left">Print functions in program</td></tr><tr><td class="left">info stack</td><td class="left">Print backtrace of the stack)</td></tr><tr><td class="left">info frame</td><td class="left">Print information about the current stack frame</td></tr><tr><td class="left">info registers</td><td class="left">Print registers and their contents</td></tr><tr><td class="left">info breakpoints</td><td class="left">Print status of user-settable breakpoints</td></tr><tr><td class="left">display /FMT EXPR</td><td class="left">Print expression EXPR using format FMT every time GDB stops</td></tr><tr><td class="left">undisplay</td><td class="left">Turn off display mode</td></tr><tr><td class="left">help</td><td class="left">Get information about gdb</td></tr></tbody></table></div></div></div><div id="postamble" class="status"><p class="creator"><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 24.5.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)</p><p class="validation"><a href="http://validator.w3.org/check?uri=referer" target="_blank" rel="external">Validate</a></p></div></body></html>]]></content>
    
    <summary type="html">
    
      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot; xml:lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;GDB常用命令汇总&lt;/title&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;meta name=&quot;generator&quot; content=&quot;Org-mode&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
 &lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: &#39;sh&#39;; }
  pre.src-bash:before  { content: &#39;sh&#39;; }
  pre.src-emacs-lisp:before { content: &#39;Emacs Lisp&#39;; }
  pre.src-R:before     { content: &#39;R&#39;; }
  pre.src-perl:before  { content: &#39;Perl&#39;; }
  pre.src-java:before  { content: &#39;Java&#39;; }
  pre.src-sql:before   { content: &#39;SQL&#39;; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]&gt;*/--&gt;
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
&lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = &quot;code-highlighted&quot;;
     elem.className   = &quot;code-highlighted&quot;;
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]&gt;*///--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;用作记录，方便查阅&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令实例 (长期更新)</title>
    <link href="tangenta.github.io/2017/09/24/Linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>tangenta.github.io/2017/09/24/Linux命令实例（长期更新）/</id>
    <published>2017-09-24T13:10:00.000Z</published>
    <updated>2018-01-13T10:49:29.383Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用linux命令<br><a id="more"></a></p><h2 id="文本文件在windows和linux之间的相互转换"><a href="#文本文件在windows和linux之间的相互转换" class="headerlink" title="文本文件在windows和linux之间的相互转换"></a>文本文件在windows和linux之间的相互转换</h2><p>差异：windows下的文本文件的编码方式默认采用的是GBK，而linux默认采用utf-8，因此同一文件在两种操作系统下可能会出现中文乱码的现象。另外，windows文件的换行符为’/r/n’，而linux文件则为’/n’，也会导致一系列奇怪问题的产生。</p><p>windows -&gt; linux: 多出来的 <strong>/r</strong> 文件换行符在vi下以 <strong>^M</strong> 的形式呈现。</p><ul><li><p>移除 <strong>^M</strong>: <code>sed -i &#39;s/^M//g&#39; fileName</code></p><blockquote><p><strong>-i</strong>  : 直接修改文件内容，不输出<br><strong>s</strong>  : 取代<br><strong>^M</strong> : 通过ctrl+v ctrl+m 输入<br><strong>g</strong>  : 应用于全局<br>‘s/匹配文本/替换文本/g’</p></blockquote></li><li><p>添加<strong>^M</strong>: <code>sed -i &#39;s/$/^M/g&#39; fileName</code></p><blockquote><p><strong>$</strong>: 匹配行末</p></blockquote></li><li><p>转换编码方式: <code>iconv -f gbk -t utf8 fileName &gt; newFileName</code></p><blockquote><p><strong>-f</strong>: from<br> <strong>-t</strong>: to</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用linux命令&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
