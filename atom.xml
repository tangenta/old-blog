<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road to PI/2</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="tangenta.github.io/"/>
  <updated>2018-03-06T12:17:31.459Z</updated>
  <id>tangenta.github.io/</id>
  
  <author>
    <name>tangenta</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>构建四则运算语法树——递归方法</title>
    <link href="tangenta.github.io/2018/03/06/%E6%9E%84%E5%BB%BA%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%AF%AD%E6%B3%95%E6%A0%91%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95/"/>
    <id>tangenta.github.io/2018/03/06/构建四则运算语法树——递归方法/</id>
    <published>2018-03-06T05:21:40.000Z</published>
    <updated>2018-03-06T12:17:31.459Z</updated>
    
    <content type="html"><![CDATA[<p>Language: C with class with stl with template with namespace.</p><a id="more"></a><p>前两天浏览了一位老友G的blog：<a href="http://gaufoo.com/2018/01/02/ni_to_pre_post/" target="_blank" rel="external">中缀表达式转化前后缀引发的思考</a></p><p>内容大概是四则运算语法树的优雅实现，看完后闻到了一股浓郁的…C的味道。为了消除诸如指针的引用、变量名大写等骚操作带来的不适感，忍不住重新实现了一遍。</p><p>本次实现借鉴(chao xi)了G的整体架构，包括类结构、函数式风格以及…变量命名——等。</p><p><img src="/images/calculate-tree-recursive.png" alt="upload successful"><br>（图片来自<a href="http://gaufoo.com/2018/01/02/ni_to_pre_post/）" target="_blank" rel="external">http://gaufoo.com/2018/01/02/ni_to_pre_post/）</a></p><p>稍有不同的地方是，与“G对表达式字符串扫描一次完成建立”相对应，我采用的是字符串的切割和构造来建立语法树。尽管这需要相对较大的开销，但我认为用这种方式来代替扫描逐个字符的做法更能突出中心思想。</p><p>待处理的算术表达式记为expression。</p><p>观察:</p><ul><li>一个expression由零或以上个factors通过+或-连接而成。</li><li>每个factor则由零或以上个terms通过*或/连接而成。</li><li>这里term是表达式的基本单位，它是一个操作数或者有括号括在最外围的整体。</li><li>此外，括号括在最外围的任意整体的内部，即除去括号后，都被归为expression。</li></ul><p>类型定义：正如上图所示，以Expr作为基类，派生出BinExpr和NumExpr。</p><p>BinExpr包含三个数据成员:运算符、第一个操作表达式和第二个操作表达式。</p><p>NumExpr仅包含一个数据成员，即值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Expr</span> &#123;</span></div><div class="line">    <span class="keyword">virtual</span> ~Expr() = <span class="keyword">default</span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinExpr</span> :</span> <span class="keyword">public</span> Expr &#123;</div><div class="line">    BinOperPtr op;</div><div class="line">    ExprPtr fst;</div><div class="line">    ExprPtr snd;</div><div class="line">    BinExpr(BinOperPtr op_p, ExprPtr fst_p, ExprPtr snd_p)</div><div class="line">        : op(op_p), fst(fst_p), snd(snd_p) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExpr</span> :</span> <span class="keyword">public</span> Expr &#123;</div><div class="line">    <span class="keyword">double</span> value;</div><div class="line">    NumExpr(<span class="keyword">double</span> v) : value(v) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>语法树结构：二元算术运算中，语法树是二叉树。每个结点(Expr)既有可能是一颗子树(BinExpr)，也可能是叶子(NumExpr)。</p><p>实现思路如下：</p><p>以二叉树为骨架意味着，必然存在指针。为堆资源管理方便起见，采用智能指针shared_ptr。相应调整并确定Expr，BinExpr和NumExpr的结构后，开始实现三个核心函数：getExpr，getFactor和getTerm。它们的作用是，将expression、factor、和term转换为一个结点指针(ExprPtr)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExprPtr <span class="title">getExpr</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div><div class="line"><span class="function">ExprPtr <span class="title">getFactor</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div><div class="line"><span class="function">ExprPtr <span class="title">getTerm</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</div></pre></td></tr></table></figure><p>可以看到，他们的参数都是字符串。当然，这些字符串要满足一定的要求才能被传入函数中。各个函数对参数的要求如下：</p><ul><li>getExpr：只要满足expression的描述即可。(例如xxx +/- xxx)</li><li>getFactor：要求参数满足factor的描述。（如不能存在游离在括号外面的+或-）</li><li>getTerm：要求参数满足term的描述（如一个数，或者括号括起来一坨东西的整体，包括括号）。</li></ul><p>和一般(利用栈)建立语法树方法不同，这里的主要思路是，每次首先找出满足条件的二元运算符，以它为中心，切割两边的字符串，再分别”递归”应用getExpr/getFactor/getTerm。（即解析字符串的时候可能存在直接或间接的递归）（此处与题目遥相呼应，可以体会到作者写作技巧的高潮..高超之处）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">ExprPtr <span class="title">getExpr</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span> &amp;expr)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> operIndex = getOper(expr, <span class="string">"+-"</span>);</div><div class="line">    <span class="keyword">if</span> (operIndex == <span class="number">0</span>) &#123; <span class="comment">// "+" or "-" not found</span></div><div class="line">        <span class="keyword">if</span> (parentheseExpr(expr))</div><div class="line">            <span class="comment">// strip outermost parenthese marks</span></div><div class="line">            <span class="keyword">return</span> getExpr(stripEnds(expr));</div><div class="line">        <span class="comment">// must be a factor</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> getFactor(expr);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// found "+" or "-" as a binary operator</span></div><div class="line">    <span class="keyword">auto</span> operIter = expr.begin() + operIndex;</div><div class="line"></div><div class="line">    BinOperPtr opExpr = char2BinOper(expr[operIndex]);</div><div class="line">    ExprPtr leftExpr = getFactor(<span class="built_in">string</span>(expr, <span class="number">0</span>, operIndex));</div><div class="line">    ExprPtr rightExpr = getExpr(<span class="built_in">string</span>(operIter + <span class="number">1</span>, expr.end()));</div><div class="line">    <span class="keyword">return</span> make_shared&lt;BinExpr&gt;(opExpr, leftExpr, rightExpr);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用人话说一遍：面对一个expression，首先拿到其中第一个（游离在括号外的）‘+-’运算符，用它之前的字符串构造一个factor，再用它之后的字符串构造一个expression，把三者粘成一颗树并返回。</p><p>实现细节：</p><p>括号处理——由于括号内的表达式具有最高优先级，因此连括号一起看，它是个term;一旦没了括号，它里面的内容就成了expression。可以想象，遇到含有括号的表达式(字符串)时，分两种情况:</p><ul><li>一种是括号存在于最外围，这时剥去括号并对其内容应用getExpr即可。</li><li>另一种是括号不在最外围，这种情况下，只要这个表达式合法，可以断言：必定存在一个二元运算符。要获得这个运算符，首先要屏蔽掉括号内相同运算符的影响。故设定一个屏蔽开关，分别由左括号控制开、右括号控制关，仅当开关处于关闭状态且目标满足要求时返回。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> getOper(<span class="built_in">string</span> <span class="keyword">const</span> &amp;expr, <span class="built_in">string</span> <span class="keyword">const</span> &amp;ops) &#123;</div><div class="line">    <span class="keyword">bool</span> enable = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != expr.size(); ++i) &#123;</div><div class="line">        <span class="keyword">char</span> ch = expr[i];</div><div class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>) <span class="comment">// ignore entities wrapped by parentheses</span></div><div class="line">            enable = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>)</div><div class="line">            enable = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (enable &amp;&amp; count(begin(ops), end(ops), ch) == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// such a binary operator doesn't exist</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输入异常(烂尾)——这里将异常为三类：二元运算符缺操作数(“3+” “-+”)、包含未知字符(“%&amp;?”)以及括号不匹配(缺左括号、右括号或”)(“)。处理方案是首先进行表达式合法性检查。</p><p>（ps： 后来发现还有”()()”，”3(2)”这些坑爹情况，关于如何一次性完成表达式的合法性检查这个问题，如果有好的想法，请email：tangenta@126.com）</p><p>总结：使用函数以递归的方式建立起语法树，与一般栈方法相比，在代码中更清晰地描述了语法树的结构(例如”一个expression由factor、加减运算符及另一个expression组成”)，构建的过程也更加直观易懂，而不像栈方法——规定了每种数字符号出现时作出的响应。</p><p>但是在另一方面，函数方法在性能上不如栈方法。在这个栗子中，除了函数调用开销以外，还有字符串构造析构产生的消耗。</p><p>从某种程度上来说，递归方法和一般方法的差别有点类似于递归过程(recursive procedure)中“递归(recursive process)”和“迭代(iterative process)”之间的区别。</p><p>最后，无源码不丈夫<a href="https://github.com/tangenta/toy/blob/master/syntatic-tree.cpp" target="_blank" rel="external">.</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Language: C with class with stl with template with namespace.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TLPI-Process</title>
    <link href="tangenta.github.io/2018/01/31/TLPI-Process/"/>
    <id>tangenta.github.io/2018/01/31/TLPI-Process/</id>
    <published>2018-01-31T09:25:00.000Z</published>
    <updated>2018-02-03T03:27:22.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程ID和父进程"><a href="#进程ID和父进程" class="headerlink" title="进程ID和父进程"></a>进程ID和父进程</h3><p>进程ID（pid）：内核中用来表示一个进程的正整数。每一个进程都与唯一的进程ID相对应。除了一些系统进程（如init），进程ID和程序之间没有必然联系（init的pid是1）。</p><p>父进程：如果说进程A是进程B的父进程，就相当于说进程B是由进程A创建的（如fork，execv等）。</p><p>每个程序都可以通过getpid和getppid来获得其运行时绑定的进程ID和父进程ID：<br><img src="/images/process-getpid.png" alt="upload successful"><br><img src="/images/process-getppid.png" alt="upload successful"></p><p>注： init是所有进程的祖先，即它是进程树的根。如果任何一个子进程的父进程结束，那它就成为了孤儿进程，被init“领养”（即在该子进程中调用getppid的返回值是1）。</p><h3 id="进程在内存中的布局"><a href="#进程在内存中的布局" class="headerlink" title="进程在内存中的布局"></a>进程在内存中的布局</h3><p>一个进程在内存中的布局可以划分为五个部分（segment），分别是：</p><ul><li>text segment：存放程序的机器代码，只读（防止运行时的意外修改），可共享（同一个程序开启多个进程）。</li><li>initialized data segment：存放显式初始化了的全局变量和静态变量。程序装载时读取。</li><li>unintialized data segment（bss segment）：存放未显式初始化的全局变量和静态变量。</li><li>stack segment：函数栈帧，存放函数的局部变量、参数及返回值，寄存器信息等。</li><li>heap seegment：堆，程序运行时可动态分配的区域。</li></ul><p>C程序中获取各部分的边界地址的方法：大部分unix实现中，都有定义三个全局变量： <code>extern char etext, edata, end;</code>，它们的地址（例如&amp;etext）分别为：text部分末尾+1（字节，下同）、data部分末尾+1、bss部分末尾+1。</p><p><img src="/images/process-memory-layout.png" alt="upload successful"></p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>上面提到的进程布局存在于虚拟内存。例如，上图中的text段的开始部分，0x8048000就是一个虚拟内存的地址。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存是每个进程独有的，一套虚拟的地址空间。我们平常说的32位系统，64位系统，这里的32,64实际上也说明了每个进程的虚拟内存的寻址范围为0～2^32或2^64字节。</p><p>虚拟内存可以被视作主存（main memory，通常为DRAM）和磁盘之间的缓存，和主存（cache和磁盘之间信息交换的媒介）一样，虚拟内存也有基本的交换单位：页（page）。每当主存需要数据时，首先找到虚拟内存查看是否存在匹配项。此时如果不存在，就相当于“cache miss”，只不过这里是另一个词——页面错误（page fault）。页面错误发生时，内核首先挂起当前进程，等待需要的数据从磁盘加载到主存中，再恢复进程，重新执行上一条未完成的指令。</p><p>那虚拟的空间怎么能存放信息呢？其实，虚拟内存的内容一部分存放在磁盘上，另一部分存放在主存中。磁盘上存放了“整个”虚拟地址空间的内容，其中的页被分成3类：已缓存的、未分配的和已分配的。已缓存，表明该页的内容已经在物理内存中;未分配，则说明该页内容还未被进程使用，因此不占磁盘空间。已分配，说明该页被进程使用过，但不在物理内存中。</p><p>为了起到缓存的作用，还需要一个结构来支持——页表（page table），它的每一个单元都代表虚存的一页，同时指向物理内存的一页（仅当该页是已缓存的）。这就形成了一个映射关系，将虚存映射到物存上了。由于页表体积较小，它可以整体地被缓存在主存中。</p><p>虚拟内存利用了大部分程序共有的<strong>局部性</strong>，提高了资源的利用率（通过整页交换来提升平均每字节传输速率），在一定程度上解决了由主存RAM和磁盘的数据传输速度差异产生的问题。</p><p>注：局部性可分为空间局部性和时间局部性。空间局部性是指，如果内存中的某个位置被访问了，那么它所在的那片空间有较大概率再次被访问。这由程序指令的顺序执行保证;时间局部性指一个程序趋向于访问它最近访问过的同一个内容，这也是程序中循环结构的特点。</p><h4 id="内存页的分配-释放"><a href="#内存页的分配-释放" class="headerlink" title="内存页的分配/释放"></a>内存页的分配/释放</h4><p>由于一个进程要访问的虚拟内存地址随着时间不断变化，内核需要不断的分配和释放内存页。一般情况下，下列动作会导致内存页的分配：</p><ul><li>栈向下增长，使得栈的大小超过了历史最大值。</li><li>堆的分配与释放，例如brk()、sbrk()或malloc家族的调用。</li><li>system V中的共享内存空间改变。</li><li>使用了内存映射接口mmap或unmmap</li></ul><h4 id="使用虚拟内存的优点"><a href="#使用虚拟内存的优点" class="headerlink" title="使用虚拟内存的优点"></a>使用虚拟内存的优点</h4><ul><li>进程隔离，每个进程有独立的页表</li><li>两个或多个进程共享物理内存：不同的页表指向同一片物理内存</li><li>访问控制更简单</li><li>编译器和连接器可以忽略物理内存实际布局</li><li>某个时间下，只有程序的一部分需要驻留在RAM中。每个进程运行时可以占用更少的资源。</li></ul><h3 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h3><p>命令行参数通过main函数的argc和argv参数传递进入程序。argc是命令参数个数，argv是命令参数内容，其中每个字符串都以’\0’结尾。argv[argc]是空指针（NULL）。</p><p>在shell中，环境变量可以通过export或setenv设置。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SHELL=/bin/bash</div><div class="line">export SHELL;</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setenv SHELL /bin/bash</div></pre></td></tr></table></figure></p><p>要在shell中查看环境变量表，可以printenv。</p><h4 id="在main函数之外获取命令行参数"><a href="#在main函数之外获取命令行参数" class="headerlink" title="在main函数之外获取命令行参数"></a>在main函数之外获取命令行参数</h4><p>通用的方法是设置全局变量或者参数传递argc和argv。另外，还可以：</p><ul><li>查看Linux特有的文件/proc/PID/cmdline或proc/self/cmdline内容。</li></ul><p>或者</p><ul><li>GNU的C函数库的<code>&lt;errno.h&gt;</code>中定义了两个变量：program_invocation_name和program_invocation_short_name，使用之前需要启用_GNU_SOURCE特性宏。</li></ul><h4 id="在程序中获取环境变量"><a href="#在程序中获取环境变量" class="headerlink" title="在程序中获取环境变量"></a>在程序中获取环境变量</h4><ul><li>直接使用全局变量<code>extern char** environ</code>，它指向环境变量列表。</li><li>另一个SUSv3标准中没有指定的方法是给main函数加上第三个参数<code>char** envp</code>很多unix实现中都可用。</li></ul><p>下面介绍几个环境变量相关的系统函数接口。</p><h5 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h5><p>获取某个环境变量的值。</p><p><img src="/images/process-getenv.png" alt="upload successful"></p><p>使用的时候要注意，不要直接修改它返回的字符串（否则<strong>可能</strong>导致环境变量被改变）。如果想要修改环境变量，应使用putenv或setenv。</p><p>另外，如果需要保留环境变量的值，在调用下一个操作环境变量的函数之前，应当先把getenv返回指针指向的内容复制出来。原因是<code>*env()</code>函数家族内部可能用一个静态数组实现字符串的存放，后续调用env函数会覆盖数组内容。</p><h5 id="putenv-setenv"><a href="#putenv-setenv" class="headerlink" title="putenv()/setenv()"></a>putenv()/setenv()</h5><p>新增或修改环境变量。</p><p><img src="/images/process-putenv.png" alt="upload successful"><br>string的格式为“<em>name=value</em>”，函数结束后，这个字符串就成为了环境变量列表的一部分（后续修改这个字符串相当于修改环境变量）。因此，这个string不能是建立在栈上的局部变量。</p><p><img src="/images/process-setenv.png" alt="upload successful"><br>如果name已经属于环境变量列表，overwrite设为0时不改变name的值; overwrite设为非0时将name的值改变为value。</p><p>setenv会将name和value指向的内容复制出来，构造出一个“name=value”格式的字符串，因此name或value是局部变量也无伤大雅。</p><h5 id="unsetenv"><a href="#unsetenv" class="headerlink" title="unsetenv()"></a>unsetenv()</h5><p>移除环境变量。</p><p><img src="/images/process-unsetenv.png" alt="upload successful"></p><h5 id="clearenv"><a href="#clearenv" class="headerlink" title="clearenv()"></a>clearenv()</h5><p>清除环境变量列表。</p><p><img src="/images/process-clearenv.png" alt="upload successful"><br>相当于<code>environ = NULL;</code>。跳转</p><p>clearenv有两个风险：首先，“setenv（里面有动态分配内存）”和“environ=NULL（暴力清除）”同时使用会导致内存泄漏，所以clearenv一般只在程序的初始化中使用。其次，SUSv3指出，显式修改了environ后（如clearenv），后续调用依赖它的getenv、unsetenv、setenv都是未定义行为（linux中的getenv等如果发现envrion是NULL，则会新创建一张表）。</p><h3 id="非局部跳转"><a href="#非局部跳转" class="headerlink" title="非局部跳转"></a>非局部跳转</h3><p>关键字goto只能实现在同一个函数内的控制权转移，这种跳转称为局部跳转。存在这种限制的原因是C语言中所有的函数都处于同一个（全局）作用域，给定任意两个函数，编译器无法确认他们之间的调用关系。又由于程序的控制权只能向调用者方向传递（不能跳转到除函数栈以外的函数的内部），无法判断调用关系也就无法实现跨函数跳转。</p><p>setjmp和longjmp为非局部跳转而生。</p><p><img src="/images/process-setjump-longjump.png" alt="upload successful"></p><p>setjmp是调用一次就能够返回两次及以上的函数。第一次返回的语义是设置跳转点，供为longjmp设定了跳转的目标，因此第一次返回值始终是0。</p><p>longjmp则是一个不会返回的函数，它简单地跳转到上一个setjmp。并在setjmp中返回，这就产生了setjmp能够返回多次的现象。</p><p>setjmp第二次及以后返回的值为longjmp中的第二个参数val（例如val == 3, setjmp的返回值也为3。但val == 0时，为了与“第一次返回”区别开来，setjmp的返回值是1）。因此，这个返回值可以被用来追溯跳转过程。</p><p>env是一个缓冲区，用于保存某个时刻的栈状态、寄存器状态（例如pc、sp），调用setjmp会将当前信息保存到env; longjmp会将栈结构和寄存器状态恢复为env。</p><p>非局部跳转内部最关键的两步：回退函数栈，重设程序计数器。</p><h4 id="setjmp的使用形式"><a href="#setjmp的使用形式" class="headerlink" title="setjmp的使用形式"></a>setjmp的使用形式</h4><p>SUSv3标准指定，setjmp的使用应遵循下列的形式：</p><ol><li>作为选择结构或循环结构的控制表达式。</li><li>作为“！”运算符的算子，结果应满足1。</li><li>作为比较运算符的算子，结果应满足1。</li><li>单独的函数调用（不与其他东西复合）。</li></ol><p><code>s = setjmp(env);</code>不满足第4点。由于setjmp不能保证有足够的信息正确地恢复<strong>复合表达式</strong>中的临时变量，应当避免与setjmp同一个语句的局部变量出现。</p><p>在满足第4点的情况下，只有选择或循环结构，能够有效利用setjump的返回值，辨别出longjmp的跳转来源。</p><p>另外，正如前面所说，“程序控制权只能向调用者方向传递”，longjmp(env)时，如果env对应的栈不在当前函数栈中（即使它以前存在过），那么这样的行为总是错误的。</p><h4 id="优化问题及建议"><a href="#优化问题及建议" class="headerlink" title="优化问题及建议"></a>优化问题及建议</h4><p>由于setjmp和longjmp建立在函数栈的基础上才能发挥作用，如果编译器将一些本应存放在栈中的局部变量优化掉了（搬到了寄存器），程序可能会产生意想不到的行为。<br>建议：局部变量总是加volatile，防止编译器优化。或者。。不用setjmp/longjmp。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程ID和父进程&quot;&gt;&lt;a href=&quot;#进程ID和父进程&quot; class=&quot;headerlink&quot; title=&quot;进程ID和父进程&quot;&gt;&lt;/a&gt;进程ID和父进程&lt;/h3&gt;&lt;p&gt;进程ID（pid）：内核中用来表示一个进程的正整数。每一个进程都与唯一的进程ID相对应。除了
      
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="TLPI" scheme="tangenta.github.io/tags/TLPI/"/>
    
  </entry>
  
  <entry>
    <title>TLPI-File I/O</title>
    <link href="tangenta.github.io/2018/01/24/TLPI-File-I-O/"/>
    <id>tangenta.github.io/2018/01/24/TLPI-File-I-O/</id>
    <published>2018-01-24T15:14:00.000Z</published>
    <updated>2018-02-03T02:44:31.869Z</updated>
    
    <content type="html"><![CDATA[<p>这一章介绍的接口有：open、read、write、close、lseek、ioctl、fcntl、dup/dup2、pread/pwrite、readv/writev、msktemp。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文件和文件标识符"><a href="#文件和文件标识符" class="headerlink" title="文件和文件标识符"></a>文件和文件标识符</h3><p>文件标识符（file descriptor，常用fd表示）是一个非负整数，程序中用于表示已经被打开了的所有文件。这里的“文件”包括pipes，FIFOs，sockets，terminals，devices等等。每一个进程都有独立的文件标识符集合。</p><p>每一个程序启动时都默认打开了三个文件，分别是标准输入流、标准输出流以及标准错误流，对应的正整数为0,1,2。</p><p><img src="/images/fileio-standardfiledescriptor.png" alt="upload successful"></p><p>文件标识符与已打开文件的关系：在unix系统中，有三个结构由内核维护，分别是：单个进程内的文件标识符表（per-process fd table）、系统范围的“已打开文件”表（open file description table）、文件系统节点表（i-node table）。为方便期间，下面简称表一、表二、表三。</p><ul><li>单个进程内的文件标识符表（表一）：存在于每个进程中，每个单元表示<strong>被该进程打开着</strong>的文件。包含的信息有，文件标识符控制标记（这里只有close-on-exec？）和指向表二中某一单元的指针。</li><li>系统范围的“已打开文件”表（表二）：存在于整个系统中，代表系统中所有<strong>被打开着</strong>的文件。包含当前文件指针偏移量、文件状态属性、文件访问控制权限、信号驱动IO设置，和指向表三中某一单元的指针。</li><li>文件系统节点表（表三）：表示系统中<strong>所有</strong>的文件。包含文件类型、访问权限、文件锁列表指针、文件属性（大小、时间戳等）等。</li></ul><p>下图表明了三者之间的联系：</p><p><img src="/images/fileio-filedescriptor-tables.png" alt="upload successful"></p><p>简单总结一下特点：</p><ol><li>同一进程的不同标识符可以指向同一个被打开着的文件，如进程A的 fd0 和fd20，可以用重定向（dup/dup2/fcntl）实现; </li><li>不同进程的标识符也可以指向同一个被打开着的文件，如 A::fd2 和 B::fd2，例如fork。</li><li>不同的“被打开着的文件”可以指向同一个文件。例如open同一个文件多次。</li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在系统接口编程中，如果一个函数或程序片段满足原子性，则CPU在执行这一片段的过程不会被打断（不会进行进程间代码执行的切换，或称上下文切换（context switch））。所有的系统函数都满足原子性。</p><p>原子性可以避免进程间的竞争冲突。例如两个进程同时对一个文件作写入操作，如果CPU在执行系统函数的过程中不断地切换上下文，最终会导致文件内容在顺序上不可预测。</p><h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p>与文件输入输出相关的系统函数主要有以下几个：</p><table><thead><tr><th>system_call_name(Type1 arg1, Type2 arg2, …) -&gt; ReturnType</th></tr></thead><tbody><tr><td>打开文件    <code>open(const char* pathname, int flags, .../* int mode */) -&gt; int fd</code></td></tr><tr><td>读取文件    <code>read(int fd, const char* buffer, int count) -&gt; int numread</code></td></tr><tr><td>写入文件    <code>write(int fd, const char* buffer, int count) -&gt; int numwritten</code></td></tr><tr><td>关闭文件    <code>close(int fd) -&gt; int status</code></td></tr><tr><td>改变文件指针 <code>lseek(int fd, off_t offset, int whence) -&gt; off_t ofs</code></td></tr><tr><td>设备控制 <code>ioctl(int fd, int request, ... /* argp */) -&gt; int *depend on request*</code></td></tr><tr><td>查询/修改文件信息 <code>fcntl(int fd, int cmd, ...) -&gt; int *depend on cmd*</code></td></tr></tbody></table><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>打开文件。</p><p><img src="/images/fileio-open.png" alt="upload successful"></p><ul><li>pathname：文件所在路径，如果是快捷方式，则找到源文件。</li><li>flags： 指定了访问方式，其中必须包含只读（O_RDONLY）、只写（O_WRONLY）和读写（O_RDWR）三种方式中的一种。其余的用位或（|）的方式指定。</li><li>mode（可选）：指定了新文件的访问权限，仅当flag包含O_CREAT时有效。</li></ul><p>flags：<br><img src="/images/fileio-open-flags.png" alt="upload successful"></p><p>这里的flags分三类：</p><ul><li>第一类是读写控制部分，占用flags的低2位。</li><li>第二类用于open的功能标志，制定了open应以什么方式工作，例如非目录报错（O_DIRECTORY）、清空文件内容（O_TRUNC）等。不能被fcntl获取或修改。</li><li>第三类是文件状态，指定了文件的属性。</li></ul><p>[注意] 如果想让程序独占（exclusively）创建文件时（即如果文件不存在，则创建并打开它; 如果文件存在，则不做动作），一个常见的错误是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>], O_WRONLY, mode)) != <span class="number">-1</span>) &#123; <span class="comment">// 打开成功（文件存在）</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"file already exists\n"</span>);</div><div class="line">    close(fd);</div><div class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 打开失败（文件不存在或者其他错误）&lt;--context switch</span></div><div class="line">    <span class="keyword">if</span> (errno != ENOENT)</div><div class="line">        errExit(<span class="string">"open"</span>);<span class="comment">//其他错误</span></div><div class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT, mode)) == <span class="number">-1</span>)</div><div class="line">        errExit(<span class="string">"open"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"create file exclusively\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>乍一看这代码应该没什么问题。但是，仔细观察可以发现，整个程序片段不满足原子性。就是说，可能存在进程间的竞争冲突。例如，执行到箭头位置时，另一个进程创建了argv[1]对应的这个文件，导致第1行判断失效。</p><p>这时，直接使用O_EXCL来打开文件可以解决这个问题：</p><p><code>open(argv[1], O_WRONLY | O_CREAT | O_EXCL, mode);</code></p><p>当文件存在时返回-1。另外，由于是单个系统函数，满足原子性。同理，O_APPEND也有类似的用途，解决了文件末尾写入的竞争冲突问题。</p><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>读取文件内容。</p><p><img src="/images/fileio-read.png" alt="upload successful"></p><ul><li>fd：文件标识符，从这里读出数据。</li><li>buffer：缓冲区，用于存放从文件中读出的信息。系统函数通常不会在它的内部分配空间，因此，为了实现系统函数和调用者（caller）之间的信息传递，需要调用者预先分配空间。</li><li>count：需要读出的字节数。</li><li>ssize_t是有符号的size_t。</li></ul><p>[注意] 在用read将文件的内容以字符串的形式输出（printf(“%s”, buffer)）时，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_READ 20</span></div><div class="line"><span class="keyword">char</span> buf[MAX_READ];</div><div class="line"><span class="keyword">if</span> (read(fd, buf, MAX_READ) == <span class="number">-1</span>)</div><div class="line">errExit(<span class="string">"read"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"The input data is: %s"</span>, buf);</div></pre></td></tr></table></figure></p><p>这样写并不能正常地输出文件中的内容，原因是read不会自动添加’\0’到buf末尾（read：我怎么知道你是以字符形式读出？）。一个比较好的处理方法是，缓冲长度设为MAX_READ+1并手动添加’\0’。</p><h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><p>向文件写入内容。</p><p><img src="/images/fileio-write.png" alt="upload successful"></p><p>参数含义与read()的一致。</p><p>[注意] 如果write成功执行（无错误），不保证写入fd的字节数等于count。磁盘空间不足，或者该进程打开的文件有大小限制，都可能导致write的返回值小于count。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>关闭文件。</p><p><img src="/images/fileio-close.png" alt="upload successful"></p><p>任何时候调用close，都应该检查它的返回值。</p><p>显式关闭不再被使用的文件，养成良好的编程习惯从我做起。</p><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h3><p>改变文件指针位置。</p><p><img src="/images/fileio-lseek.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>offset：偏移量（字节）。</li><li>whence：指定了偏移量从哪里开始算。whence的值可以为以下三种之一：<ul><li>SEEK_SET，从头算。</li><li>SEEK_CUR，从现在的位置算。</li><li>SEEK_END，从文件末尾开始算。</li></ul></li></ul><p><img src="/images/fileio-lseek-whence.png" alt="upload successful"></p><p>[注意] lseek不能被使用在pipe、FIFO、socket或者terminal中，否则errno被置为ESPIPE。</p><p>文件洞： lseek函数通过指定whence为SEEK_END，可以将文件指针移到没有数据的地方。这时如果向文件写入一些内容，原文件的末尾和新内容的开头之间就形成了空洞，文件体积（size）也随之变大; 但是这些空洞不占据磁盘空间。</p><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl()"></a>ioctl()</h3><p>用于设备的I/O控制，作为标准IO模型的补充。</p><p><img src="/images/fileio-ioctl.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>request：运作方式，每个设备都定义了独立的常量。其中的信息包含：输入/输出，argp的大小（字节）。</li><li>argp：指向内存的指针。类型取决于request，通常用作输入输出缓冲。</li></ul><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p><img src="/images/fileio-fcntl.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>cmd：决定了运作方式和第三个参数的类型。</li></ul><h4 id="获取-修改文件的flags"><a href="#获取-修改文件的flags" class="headerlink" title="获取/修改文件的flags"></a>获取/修改文件的flags</h4><p>（这里只能获取第一类和第三类flags，见open()一节）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> flags, accessmode;</div><div class="line">flags = fcntl(fd, F_GETFL);</div><div class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>) errExit(<span class="string">"fcntl"</span>);</div></pre></td></tr></table></figure></p><p>检验第一类（访问控制）flags：</p><p><code>if (flags &amp; O_SYNC) printf(&quot;writes are synchronized.\n&quot;);</code></p><p>检验第三类（文件状态）flags：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">accessmode = flags &amp; O_ACCMODE;</div><div class="line"><span class="keyword">if</span> (accessmode == O_WRONLY || accessmode == O_RDWR)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"file is writable.\n"</span>);</div></pre></td></tr></table></figure></p><p>[注意] 由于三个模式只占flag的低2位，这里不能简单地<code>flag &amp; O_xxx</code>。</p><p>修改flags的过程是获取并重新设置flags的过程。要设置flags，只需将fcntl的cmd部分改为<strong>F_SETFL</strong>，并把flags作为第三个参数即可：<br><code>fcntl(fd, F_SETFL, flags);</code></p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>功能类似于dup/dup2，cmd设为<strong>F_DUPFD</strong>，用法如下：</p><p><code>newfd = fcntl(oldfd, F_DUPFD, startfd);</code></p><p>作用是从startfd开始，在所有数值上大于startfd的标识符中选择最小可用的fd，使它指向oldfd指向的内容，返回新的标识符。这时对新标识符的读写相当于对oldfd的读写。</p><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup()/dup2()"></a>dup()/dup2()</h3><p>产生一个新的文件标识符，使其指向已有的被打开着的文件。</p><p><img src="/images/fileio-dup.png" alt="upload successful"></p><p><img src="/images/fileio-dup2.png" alt="upload successful"></p><ul><li>oldfd：文件标识符，指向已被进程打开了的文件。</li><li>newfd：新的文件标识符。</li></ul><p>dup与dup2不同之处在于，dup把可用的（即未绑定打开着的文件）数值上最小的文件标识符用作新的标识符。另外，dup2会将newfd指向的文件（如果有）关闭（忽略关闭错误），除非oldfd不可用。</p><h3 id="pread-pwrite"><a href="#pread-pwrite" class="headerlink" title="pread()/pwrite()"></a>pread()/pwrite()</h3><p>不改变文件指针位置的读写方式。</p><p><img src="/images/fileio-pread-pwrite.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>buf：缓冲区。</li><li>count：读出/写入的最大字节数。</li><li>offset：文件指针偏移量（从文件开头计算）。</li></ul><p>pread/pwrite的引入将lseek和read/write结合起来并赋予了原子性，避免了多线程环境下的读写竞争冲突。同时，在性能上也有所提高。</p><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv()/writev()"></a>readv()/writev()</h3><p>集散I/O：在一个系统调用中完成多个缓冲区的读取/写入。</p><p><img src="/images/fileio-readv-writev.png" alt="upload successful"></p><ul><li>fd：文件标识符。</li><li>iov：一些列缓冲区的集合。</li><li>iovcnt：缓冲区集合的个数。</li></ul><p>第二个参数的结构如下图所示：</p><p><img src="/images/fileio-readv-writev-iov.png" alt="upload successful"></p><p>iov_base和iov_len分别指定了缓冲区的首地址和缓冲区的长度。缓冲区可以是所有类型的变量，包括结构体、整数、字符串等。</p><h3 id="truncate-ftruncate"><a href="#truncate-ftruncate" class="headerlink" title="truncate()/ftruncate()"></a>truncate()/ftruncate()</h3><p>设置文件为指定大小。</p><p><img src="/images/fileio-truncate-ftruncate.png" alt="upload successful"></p><ul><li>pathname：文件路径。</li><li>fd：文件标识符。</li><li>length：文件大小（字节）。</li></ul><p>如果length小于原文件大小，则多出的部分被丢弃; 如果length大于原文件大小，剩余部分则填充’\0’或者作为文件洞。truncate/ftruncate要求文件可访问、可写。另外，文件指针不会被改变。</p><h3 id="msktemp"><a href="#msktemp" class="headerlink" title="msktemp()"></a>msktemp()</h3><p>建立一个临时文件。</p><p><img src="/images/fileio-mkstemp.png" alt="upload successful"></p><ul><li>template：字符数组，内容为路径，最后六个字符必须为XXXXXX。函数结束时最后六个字符被替换为随机字符，使得文件名唯一。</li></ul><p><code>&lt;stdio.h&gt;</code>中的<code>FILE* tmpfile(void)</code>也有类似的功能，但更为简便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章介绍的接口有：open、read、write、close、lseek、ioctl、fcntl、dup/dup2、pread/pwrite、readv/writev、msktemp。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="tlpi" scheme="tangenta.github.io/tags/tlpi/"/>
    
  </entry>
  
  <entry>
    <title>TLPI-系统编程概念</title>
    <link href="tangenta.github.io/2018/01/21/TLPI-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>tangenta.github.io/2018/01/21/TLPI-系统编程概念/</id>
    <published>2018-01-21T03:15:00.000Z</published>
    <updated>2018-01-24T09:59:53.673Z</updated>
    
    <content type="html"><![CDATA[<p>system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。</p><a id="more"></a><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统函数（system call）是进程向内核请求服务的入口，是系统编程的接口（API）。内核提供各种各样的服务，例如创建新进程、实行IO操作、进程间通信等等。</p><p>系统调用有如下特征：</p><ul><li>每次进行系统调用，都会将处理器的状态从“用户模式”转换为“内核模式”。</li><li>系统函数的集合是固定的，每个系统函数都由独一无二的数字标识。</li><li>每个系统函数原型都包含一个或多个形参。</li></ul><p>在C语言中，系统函数调用的过程：</p><ol><li>调用C函数库中的封装函数</li><li>封装函数保证调用系统函数时对应参数位置的正确性</li><li>调用系统函数前，封装函数将系统函数对应的数字赋值到寄存器eax中</li><li>执行trap机器指令（0x80），导致程序计数器跳转到0x80，处理器模式也从用户模式转换为内核模式</li><li>开始调用system_call()。它作出下列行为：<ul><li>寄存器的值入栈。</li><li>检验系统调用的合法性。</li><li>根据sys_call_table找到并调用相应的系统函数。</li><li>恢复寄存器值，系统函数的返回值入栈。</li><li>返回到封装函数，切换模式。</li></ul></li><li>系统调用被反应到全局变量errno，从封装函数返回</li></ol><p>[注] 通常情况下，调用系统函数的开销是普通函数的数十倍。</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>库函数是C标准库中的重要组成部分。其中既包括与系统函数无关的函数，例如字符串处理函数; 又有系统函数的封装器，例如fopen，printf，malloc，free等等——这类库函数通常为简化系统函数的使用而被设计出来。</p><h3 id="系统-库函数的错误处理"><a href="#系统-库函数的错误处理" class="headerlink" title="系统/库函数的错误处理"></a>系统/库函数的错误处理</h3><p>除了测试返回值以外，多数系统函数在出现异常时会设置全局变量errno（通常与<code>&lt;errno.h&gt;</code>中定义的常量配合使用）。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cnt = read(fd, buf, numbytes);</div><div class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>) &#123;</div><div class="line"><span class="keyword">if</span> (errno == EINTR)</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read was interrupted by a signal\n"</span>);</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">/* Some other error occurred */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>&lt;errno.h&gt;</code>中定义的所有表示错误的常量都以E开头。man手册中，每一个系统函数的ERRORS部分标注了所有可能产生的错误。例如close(int fd)：</p><p><img src="/images/systemconcept-close-error.png" alt="upload successful"></p><p>[注意] errno表示<strong>上一次</strong>错误的数字代号。也就是说，如果系统调用正常返回，它不会对errno进行重设。因此，在使用errno之前，都应当先检查返回值。<br>此外，还有一种常见的错误使用errno的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"somacall() failed\n"</span>);</div><div class="line">    <span class="keyword">if</span> (errno == ...) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>错误之处在于printf可能会重设errno。用C++的话来说，这不是异常安全的。<br>正确写法是第一步先保存errno的值。</p><p>[注意] 不要手动声明errno(即<code>extern int errno;</code>)，而应该使用<code>#include &lt;errno.h&gt;</code>的方式声明。</p><h4 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg )</span></span>;</div></pre></td></tr></table></figure><p>输出字符串msg和errno对应的描述到标准错误流上。</p><p><img src="/images/systemconcept-perror.png" alt="upload successful"></p><h4 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns pointer to error string corresponding to errnum</span></div></pre></td></tr></table></figure><p>遇到未知错误代码时，返回的字符串为“unknown error nnn”。但在一些strerror实现中，也有可能是NULL。</p><p><img src="/images/systemconcept-strerror.png" alt="upload successful"></p><p>[注意] 部分库函数遇到错误不会设置errno，这种情况下，不应使用perror()或strerror()来检查错误。</p><h3 id="常用头文件和错误处理函数"><a href="#常用头文件和错误处理函数" class="headerlink" title="常用头文件和错误处理函数"></a>常用头文件和错误处理函数</h3><p>perror和strerror功能分别是输出错误信息和翻译错误码，但在linux系统编程中仅仅有这两个是不够方便的。下面给出几个实用的错误报告函数（它们的实现在这里：<a href="https://gitee.com/tangenta/TLPI-study-notes/blob/master/tlpi_hdr.h" target="_blank" rel="external">tlpi-hdr.h</a>）：</p><ul><li><strong><code>void errMsg(const char* format, ...)</code></strong>： 有格式控制输出的perror()</li><li><strong><code>void errExit(const char* format, ...)</code></strong>： errMsg后退出程序</li><li><strong><code>void err_exit(const char* format, ...)</code></strong>： 类似errExit，退出时<strong>不刷新</strong>stdout缓冲区</li><li><strong><code>void errExitEN(int errnum, const char* format, ...)</code></strong>： 用errnum代替errno的errExit(多线程中，errno是函数调用，使用errExitEN()有利于提高效率)</li><li><strong><code>void fatal(const char* format, ...)</code></strong>： 用来诊断通用错误（即包括不会设置errno的错误），<strong>不使用</strong>errno，采用errExit退出程序。</li><li><strong><code>void usageErr(const char* format, ...)</code></strong>： 字符串前置”Usage:”</li><li><strong><code>void cmdLineErr(const char* format, ...)</code></strong>： 用于表示命令行参数错误</li></ul><p>下面是命令行解析函数（分别是int和long）：</p><ul><li><strong><code>int getInt(const char* arg , int flags , const char* name)</code></strong></li><li><strong><code>long getLong(const char* arg , int flags , const char* name)</code></strong></li></ul><p>如果arg指向的字符串不能被转换为整数，则报错并终止程序。</p><p>flag可以设定<strong>大小</strong>——非负(GN_NONNEG)、正(GN_GT_0)和<strong>进制</strong>——任意进制(GN_ANY_BASE)、八进制(GN_BASE_8)、十六进制(GN_BASE_16)。大小和进制可以用或（|）来同时设定。</p><p>name可以自己设定，输出结果以…(in <em>name</em>)…显示。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul><li><p>特性检测宏(feature test macros)</p><p>  由于不同的标准主导了系统函数和库函数的API，要使程序具有可移植性，就要做到在头文件中只暴露某些平台相关的定义。</p><p>  可以通过<code>#define xxx</code>或者在编译选项加上<code>-D xxx</code>，让程序得以在遵循这些标准的系统上正常运行。</p></li><li><p>系统数据类型(system data type)</p><p>  我们常常可以看到一些typedef，例如size_t，pid_t等等，应用这些数据类型而非直接使用C语言中的int，long的原因就是能够提高可移植性。例如存放进程ID，有些系统需要4个字节的空间，另一些则用8个字节。我们写程序时可以用pid_t来消除“用int还是long”的麻烦。</p><p>  用printf输出这些数据类型时，由于程序在运行时无法得知“系统数据类型”对应的“C类型”，用”%d”还是用”%ld”就成了问题。一个解决方案是，对所有系统数据类型变量先强制转换为long，以”%ld”的形式输出。</p></li></ul><ul><li><p>结构体</p><p>  一些标准中的部分结构体没有指定内部成员的相对次序。在初始化时，为了提高可移植性，不应使用 <code>struct somestruct s = {a1, a2, a3}</code> 这种形式，而应显式初始化。</p></li></ul><ul><li><p>非通用的宏</p><p>  有些宏不是在所有实现都有定义。使用它们的时候应用<code>#ifdef xxx</code>包裹起来。</p></li><li><p>头文件</p><p>  同一个定义在不同的标准下，可能会位于不同的头文件中。为了尽可能提高可移植性，可以考虑包含多个标准指定的头文件。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;system programming concepts…这一章的名字起得不好，明明只介绍了系统/库函数，相应的错误处理和可移植性问题。。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
      <category term="TLPI" scheme="tangenta.github.io/tags/TLPI/"/>
    
  </entry>
  
  <entry>
    <title>GDB奇技淫巧</title>
    <link href="tangenta.github.io/2017/12/26/gdb-trick/"/>
    <id>tangenta.github.io/2017/12/26/gdb-trick/</id>
    <published>2017-12-26T02:00:00.000Z</published>
    <updated>2018-01-24T09:53:40.879Z</updated>
    
    <content type="html"><![CDATA[<p>学会了这个，调试速度马上提高1.005倍！点击阅读原文</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="执行外部shell命令"><a href="#执行外部shell命令" class="headerlink" title="执行外部shell命令"></a>执行外部shell命令</h3><p>在不退出gdb的情况下执行/bin/sh命令(无视alias，用起来可能不是特别方便)：</p><p><code>(gdb)!clang++ test.cpp -o test</code> </p><p>或者</p><p><code>(gdb)shell clang++ test.cpp -o test</code></p><hr><h3 id="记录调试信息"><a href="#记录调试信息" class="headerlink" title="记录调试信息"></a>记录调试信息</h3><p>将调试产生的输出保存到文件中(file默认是gdb.txt)，便于日后分析：</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set logging on/off</td><td>调试信息记录开启/关闭</td></tr><tr><td>set logging file [file]</td><td>设置保存记录的文件名</td></tr></tbody></table><hr><h3 id="设置程序启动参数"><a href="#设置程序启动参数" class="headerlink" title="设置程序启动参数"></a>设置程序启动参数</h3><p>程序运行参数太多，每次run要写一堆参数？exec-wrapper或args解放双手：</p><ul><li>exec-wrapper：存放了用于启动程序的shell命令。在gdb中运行run时，通过exec-wrapper来启动程序，然后将控制权转交给gdb。如果exec-wrapper为空，则会执行已被连接的target(即默认情况)。</li><li>args：存放了需要传递给被调试程序的参数。运行run时，args内的字符串被当作参数传递给程序。</li></ul><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>show args</td><td>显示run附带的参数</td></tr><tr><td>show exec-wrapper</td><td>显示exec-wrapper的内容</td></tr><tr><td>set exec-wrapper “./a.out -arg”</td><td>设置启动命令为”./a.out -arg”</td></tr><tr><td>set args “-arg1 -arg2 -arg3”</td><td>设置运行参数为”-arg1 -arg2 -arg3”</td></tr><tr><td>unset exec-wrapper</td><td>删除exec-wrapper</td></tr></tbody></table><hr><h3 id="存档机制"><a href="#存档机制" class="headerlink" title="存档机制"></a>存档机制</h3><p>调试错过了翻车地点？存档机制逆转时空，restart一下就好了，不必重新运行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>checkpoint</td><td>保存当前程序状态(通过fork实现)</td></tr><tr><td>info checkpoints</td><td>查看存档信息(每个checkpoint都有自己的id)</td></tr><tr><td>restart checkpoint-id</td><td>恢复第checkpoint-id个存档的信息</td></tr><tr><td>delete checkpoint checkpoint-id</td><td>删除第checkpoint-id个存档的信息</td></tr></tbody></table><p>注意：恢复程序的状态不包括恢复pid值、对外部文件或进程的操作。例如打印到文件流的信息不能被吸回来，删掉的外部文件不能被恢复，等等。</p><hr><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><h4 id="断点的设置-删除"><a href="#断点的设置-删除" class="headerlink" title="断点的设置/删除"></a>断点的设置/删除</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>tbreak</td><td>一次性断点，用完自动删除</td></tr><tr><td>rbreak <em>regex</em></td><td>正则断点，匹配满足条件的名字</td></tr><tr><td>break 5 if <em>condition</em></td><td>在第5行设置一个断点，满足condition时暂停程序</td></tr><tr><td>watch [-location] <em>expr</em></td><td>数据断点，当expr[-location:指向]的值发生改变时暂停程序</td></tr><tr><td>rwatch [-location] <em>expr</em></td><td>数据断点，expr被读取时暂停程序</td></tr><tr><td>awatch [-l] <em>expr</em></td><td>数据断点，expr被读取或写入时暂停程序</td></tr><tr><td>clear [filename:]function/linenum</td><td>删除函数或行号上的所有断点</td></tr><tr><td>delete</td><td>删除所有断点</td></tr></tbody></table><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>condition <em>bnum</em> <em>expr</em></td><td>在第bnum个断点上设置程序暂停条件expr</td></tr><tr><td>condition <em>bnum</em></td><td>取消第bnum个断点的程序暂停条件</td></tr><tr><td>ignore <em>bnum</em> <em>count</em></td><td>第bnum个断点被触发count次后暂停程序</td></tr></tbody></table><h4 id="断点命令commands…end"><a href="#断点命令commands…end" class="headerlink" title="断点命令commands…end:"></a>断点命令commands…end:</h4><p>遇到断点时，执行command和end之间的命令。<br>command和end分别用于标记断点命令表的开始和结束，而主体部分的命令将绑定在最近设置的断点上。例如：</p><pre><code>(gdb)break 7(gdb)commandssilentprintf &quot;x is %d\n&quot;, xcontinueend</code></pre><p>在编号为7的断点上设置了断点命令——slient(静默处理断点停止信息)、printf(输出x的值)、continue(继续运行程序)。</p><h4 id="断点的保存-恢复"><a href="#断点的保存-恢复" class="headerlink" title="断点的保存/恢复"></a>断点的保存/恢复</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>save breakpoints <em>filename</em></td><td>以命令的形式将所有断点保存到文件中</td></tr><tr><td>source <em>filename</em></td><td>执行filename文件的内容(这里是恢复断点)</td></tr></tbody></table><hr><h3 id="恢复运行与单步调试"><a href="#恢复运行与单步调试" class="headerlink" title="恢复运行与单步调试"></a>恢复运行与单步调试</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>continue<br> step [count]<br> next [count]<br> finish<br> until [count]</td><td>常规操作</td></tr><tr><td>until</td><td>继续运行程序，直到后一条指令被执行为止</td></tr><tr><td>stepi<br> si</td><td>执行一条机器指令，进入函数(如果有)</td></tr><tr><td>nexti<br> ni</td><td>执行一条机器指令，不进入函数</td></tr><tr><td>skip <em>file</em><br> skip <em>function</em></td><td>跳过不需要调试的文件/函数</td></tr><tr><td>skip enable/disable/delete [range]</td><td>启用/禁用/删除skips</td></tr></tbody></table><ul><li>until：这里的后一条指令是指，以内存地址值大小的”小于”作为指令的偏序关系，当前指令的最小上界。主要用于跳出循环。注意：如果看到执行完until的效果是，执行的语句反而”倒退”了，则很可能是编译器进行了机器指令位置上的调整(例如while改为了do-while)。</li></ul><hr><h3 id="录制与回放"><a href="#录制与回放" class="headerlink" title="录制与回放"></a>录制与回放</h3><p>将问题锁定在程序的某个区间后，如果需要反复逐条指令地运行这一段代码，可以采用gdb提供的录制回放功能。</p><p>gdb录制-回放模式: 在这个模式中，如果下一条指令已在记录中，gdb会以回放模式执行该指令(即并非真正运行该指令，而是从记录中读取与这条指令相关的信息，改变程序状态)。否则，gdb以录制模式执行该指令(将与之关联的信息保存到记录中)。多数情况下，回放模式支持逆行。以下是相关命令：</p><ul><li><p><strong>record <em>method</em></strong> 启用录制-回放模式，其中”<em>method</em>“可被以下参数代替：</p><ul><li><strong>full(default)</strong> 使用软件实现录制和回放，支持逆行。(随手测试100多条C++语句，产生大约3M的信息)</li><li><strong>btrace <em>format</em></strong><br>使用硬件支持录制状态。录制的内容不能保存到文件中;数据被保存在一个环状缓冲区——如果缓冲区已满，则会覆盖前面的数据。<em>format</em>可以被以下参数代替:<ul><li><strong>bts</strong> Branch trace store录制格式，储存每一个分支。</li><li><strong>pt</strong> Intel processor trace录制格式，储存之前经过压缩。</li></ul></li></ul><p>full方式不能用在non-stop mode和asynchronous execution mode。它们只能支持btrace方式。(?_?)</p></li><li><strong>record stop</strong> 删除所有记录，并退出录制-回放模式。</li><li><strong>record delete</strong> 抛弃前面录制的所有内容，从当前指令重新开始录制</li><li><strong>record goto <em>location</em></strong> 读取特定位置的记录。<em>location</em>可被以下参数代替：<ul><li><strong>begin/start</strong> 开始</li><li><strong>end</strong> 结束</li><li><strong>n</strong> 第n个指令</li></ul></li><li><strong>record save <em>filename</em></strong> 将记录存到filename文件中，默认为gdb_record.process_id。</li><li><strong>record restore <em>filename</em></strong> 从filename文件中读取记录。</li></ul><p>杂项：</p><ul><li><strong>set/show record full insn-number-max <em>limit</em></strong> 设置/查看最大记录指令数，<em>limit</em>可以为正整数或”unlimited”。</li><li><strong>set/show full stop-at-limit</strong> 指令数达到最大记录时，暂停程序</li><li><strong>set/show record btrace bts/pt buffer-size</strong> 设置btrace方式的缓冲区容量</li><li><strong>record instruction-history *</strong> 对录制的指令反汇编及相关操作</li></ul><h3 id="逆行"><a href="#逆行" class="headerlink" title="逆行"></a>逆行</h3><p>调试过程中的逆行，可以使程序逐步恢复到执行各指令之前的状态，包括寄存器、内存、输入输出设备等。一般情况下，在回放模式中可以逆行。</p><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>set exec-direction forward/reverse</td><td>设置程序的运行方式为正向/逆向</td></tr><tr><td>reverse-<em>command</em></td><td>以逆向的方式执行<em>command</em>命令</td></tr></tbody></table><p>注意：上面的command可以被continue / step / stepi / next / nexti / finish任何一条命令替换。另外，如果exec-direction被设置为了逆向(reverse)，”<em>command</em>“和”reverse-<em>command</em>“的功能也被对换。</p><hr><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>backtrace full [n/-n] bt full [n/-n]</td><td>展示[最内/外n层的]栈回溯和局部变量</td></tr><tr><td>frame n f n</td><td>选择第n个函数栈</td></tr><tr><td>up/down n</td><td>进入上n级/下n级函数栈，n缺省为1</td></tr><tr><td>info frame info f</td><td>显示当前函数栈的详细信息，包括： 上/下级栈地址、源代码语言、函数参数地址、局部变量地址、上级函数栈指针sp、被保存的寄存器地址</td></tr><tr><td>info args/locals</td><td>显示函数参数/局部变量的信息 </td></tr></tbody></table><hr><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>disassemble /s</td><td>同时展示源代码和汇编代码</td></tr><tr><td>disassemble /r</td><td>同时展示机器代码和汇编代码</td></tr><tr><td>disassemble <em>begin</em>, <em>end</em></td><td>展示从begin到end的汇编代码</td></tr></tbody></table><hr><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul><li>类型检验/转换<ul><li><strong>ptype exp</strong> ：给定某个表达式，检验其运算结果的类型。如果exp是用户自定义类型，则输出该类型的源码; 如果是函数，则输出函数原型。</li><li><strong>p {type} addr</strong> ：以类型“type”输出地址“addr”的内容。比如：<code>p {int}0x618c20</code> 的含义是：将0x618c20处的内容“强制转换”为int，输出。</li></ul></li><li><p>数组访问</p><ul><li><strong>p *array@len</strong> ：表达式“*array@len”的结果是一个长度为len的数组，类型由array决定。其中“@”是一个二元运算符，左边是数组的第一个元素(必须在内存中)，右边是数组元素个数。</li><li><strong>p/x (type[])addr</strong> ：将addr强制转换为数组并输出。例如 <code>p (short[])0x12345678</code>的输出结果为$1 = {0x1234, 0x5678}。方括号内可以填入元素个数。</li><li><p>如果要访问的是指针数组中每个指针指向的对象，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set $i = 0</div><div class="line">p arr[$i++]-&gt;vp</div><div class="line">RET</div><div class="line">RET</div></pre></td></tr></table></figure><p>  其中RET是回车。</p></li></ul></li><li><p><strong>print/<em>format</em> val</strong>： 格式化输出val。其中format可以被以下字符代替：</p></li></ul><table><thead><tr><th>format</th><th>description</th></tr></thead><tbody><tr><td>x</td><td>int(hex)，十六进制整数</td></tr><tr><td>d</td><td>int(dec)，十进制整数</td></tr><tr><td>u</td><td>(unsigned)int，无符号整数</td></tr><tr><td>o</td><td>int(oct)，八进制整数</td></tr><tr><td>t</td><td>int(bin)，二进制整数</td></tr><tr><td>a</td><td>address，地址</td></tr><tr><td>c</td><td>char，字符</td></tr><tr><td>f</td><td>float，浮点数</td></tr><tr><td>s</td><td>string，尽可能转换为字符串</td></tr><tr><td>z</td><td>leading zero hex，十六进制整数，前面填充0</td></tr><tr><td>r</td><td>raw，原始形式</td></tr></tbody></table><ul><li><p><strong>x/<em>nfu</em> addr</strong>： 以一定的格式输出地址addr中的内容。</p><ul><li>n：repeat count，如果n是负数，则向前数-n个;     </li><li>f： format，和上述format含义相同; </li><li>u： unit size，可以是“b、h、w、g”中的一个，分别代表1、2、4、8个字节。</li></ul><p>执行完一条x addr命令以后，该结果临时保存在$_（美元符+1个下划线），addr的值临时保存在$__（美元符+2个下划线），方便下次取用。</p></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p>待填的坑：</p><ul><li>环境变量/工作目录/输入输出设备设置</li><li>远程调试正在运行的程序</li><li>多进程/多线程下的调试</li><li>catchpoint的使用</li><li>动态输出(dynamic printf)</li><li>静态探查点(static probe points)</li><li>信号</li><li>frame filter</li><li>动态连接程序的反汇编</li><li>数据类型探索(explore data)</li><li>convenience variables/functions</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学会了这个，调试速度马上提高1.005倍！点击阅读原文&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>真·「stack_overflow」</title>
    <link href="tangenta.github.io/2017/12/04/stack-overflow/"/>
    <id>tangenta.github.io/2017/12/04/stack-overflow/</id>
    <published>2017-12-04T12:09:00.000Z</published>
    <updated>2018-01-13T10:52:22.267Z</updated>
    
    <content type="html"><![CDATA[<p>前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的<a href="http://csapp.cs.cmu.edu/2e/home.html" target="_blank" rel="external">配套网站</a>和里面的<a href="http://csapp.cs.cmu.edu/2e/labs.html" target="_blank" rel="external">实验室</a>献上。。没有膝盖了，就点个赞吧。<br><a id="more"></a></p><hr><p>2018.01.13更新：初次实践，玩溢出的时候走了一些弯路：比如肉眼看内存状况，以及注入冗余代码等等。关于注入代码中的函数调用模拟：</p><blockquote><p>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">movl $0x1005b2b7,%eax</div><div class="line">pushl $0x8048dbe</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $0x38,%esp</div><div class="line">leave</div><div class="line">ret</div></pre></td></tr></table></figure></p></blockquote><p>这段说法存在问题。从代码分析可以发现，用于建立新函数栈的第3-5行可以和用于回收函数栈的第6行相互抵消。而ret的作用仅仅是pop返回地址+程序跳转，除了sp++之外，没有对栈结构造成其他影响。因此也没有“程序认为我们已经返回到了test中”这种说法。。</p><p>归根结底，还是对汇编指令与栈结构之间的联系理解得不够深刻。</p><hr><p>————原文分割线————</p><hr><p>栈溢出攻击：对于读入字符串时没有边界检查的程序，利用字符串不断写入信息覆盖返回值，使程序计数器跳转到指定位置，执行特定代码的行为。</p><p>下面是一个栗子(代码和图片都来自CSAPP)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> c;</div><div class="line"><span class="keyword">char</span> *dest = s;</div><div class="line"><span class="keyword">int</span> gotchar = <span class="number">0</span>; <span class="comment">/* Has at least one character been read? */</span></div><div class="line"><span class="keyword">while</span> ((c = getchar()) != ’\n’ &amp;&amp; c != EOF) &#123;</div><div class="line">*dest++ = c; <span class="comment">/* No bounds checking! */</span></div><div class="line">gotchar = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">*dest++ = ’\<span class="number">0</span>’; <span class="comment">/* Terminate string */</span></div><div class="line"><span class="keyword">if</span> (c == EOF &amp;&amp; !gotchar)</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* End of file or error */</span></div><div class="line"><span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Read input line and write it back */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></div><div class="line">gets(buf);</div><div class="line"><span class="built_in">puts</span>(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码经过gcc -m32编译过后产生一个在IA32处理器上运行的程序。<br>下图为程序执行到echo函数中的gets(buf)时的内存结构，地址数值从上往下递减。寄存器%ebp是echo的框架指针，并且白色矩形从上至下依次为：</p><ul><li>return address: 函数结束时的返回地址，即PC要跳转的地址;</li><li>saved %ebp: echo()调用者的框架指针;</li><li>saved %ebx: 具有callee-saved性质的寄存器保存的值;</li><li>buf[0]-buf[7]: 在栈上申请的空间，用于存放gets即将读入的字符串。<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></li></ul><p>栈溢出攻击要做的就是不断填入字符，一直延伸到返回地址并用“有效返回地址”覆盖它。这样函数在返回的时候PC就会跳转到我们想去的地方，执行想执行的命令，美滋滋。<br>好，今天就到此为止。</p><p><img src="/2017/12/04/stack-overflow/fakeEnd.png" width="100%" height="100%"></p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p><p>。。<br><br></p><p>到此为止是不可能到此的，这辈子都不可能到此为止，上面只是一个复习而已啦。下面开始进入正题：挽起袖子动手实现栈溢出。<br>原料：CSAPP实验室提供的bufbomb一枚，可以在Buffer Lab的Self-study Handout获得。<br>工具：gdb，objdump，gcc和脑子。</p><p>依题意得，该程序会调用下面的test函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="comment">/* Put canary on stack to detect possible corruption */</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</div><div class="line">val = getbuf();</div><div class="line"><span class="comment">/* Check for corrupted stack */</span></div><div class="line"><span class="keyword">if</span> (local != uniqueval()) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has been corrupted\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned 0x%x\n"</span>, val);</div><div class="line">validate(<span class="number">3</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">/* Buffer size for getbuf */</span></div><div class="line"> <span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">Gets(buf);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从命题人的角度分析，这个getbuf()是考察重点。鉴于它想用32个字节的数组容纳键盘输入的数据，看起来像个老实人，试探它一下：<br><img src="/2017/12/04/stack-overflow/typestring.png" width="80%" height="80%"><br>我写了34个字符还能让我走，果然是个老实人，可以欺负。</p><p>现在可以定一个小目标：通过外部输入，让test函数执行它的第二个条件分支语句<strong>else if (val == cookie) {…</strong></p><p>分析一下，要让首先要让val==cookie成立。(考虑到这是一个assignment，当然要有机制来防止抄袭，这里cookie就是一个根据用户名生成的一个值。这里我的用户名使用的是bovik，对应的cookie值是0x1005b2b7)<br>就是说，要把val改为0x1005b2b7。又观察到val = getfuf()，所以我们只需要把getbuf()的返回值从1改为0x1005b2b7就好了。</p><p>具体的流程是，取得程序的控制权-&gt;执行特定的机器指令-&gt;归还控制权。</p><p>首先，掏出工具看看getbuf的汇编代码：</p><blockquote><p><code>$ objdump -d bufbomb | grep -20 &quot;&lt;getbuf&gt;&quot;</code><br><img src="/2017/12/04/stack-overflow/getbuf.png" width="100%" height="100%"><br>可以看到进入函数以后，在栈分配了0x38字节的空间，其中0x28是用来放准备从键盘读入的字符(0x20)和上一级的框架指针位置ebp(0x8);最低的0x8用来存Gets的参数;中间空了的0x8不知道拿来干嘛的。。<br>值得一提的是，这个%eax存放的0x1就是目标，在注入的机器指令中要修改它的值。</p></blockquote><p>然后侦查一波，检查getbuf调用时的内存状况：</p><blockquote><p><code>$ gdb ./bufbomb</code>      #  进入gdb<br><code>(gdb) b getbuf</code>        #  在getbuf设置断点<br><code>(gdb) r -u bovik</code>    #  执行，这里的bovik就是用户名<br><img src="/2017/12/04/stack-overflow/bgetbuf.png" width="100%" height="100%"><br>cookie值：0x1005b2b7<br><img src="/2017/12/04/stack-overflow/stopAtGetbuf.png" width="100%" height="100%"><br>好，程序已经停在了断点处，可以开始观察了：<br><code>(gdb) info register</code> #  查看寄存器情况<br><img src="/2017/12/04/stack-overflow/infoRegis1.png" width="100%" height="100%"><br>主要关注ebp和esp。0xb0-0x78 == 0x38，和分析的一致，稳。<br>最关键的部分来了：内存现场<br><code>(gdb) x/80bx $esp</code>   #  以16进制查看从$esp开始，80个字节的内存情况<br><img src="/2017/12/04/stack-overflow/initMem.png" width="100%" height="100%"><br>白色高亮部分左边的0x556835b0就是当前框架指针ebp的值。<br>如果不出意外，这里包含了上级框架指针%ebp地址和返回地址。</p></blockquote><p>要取得程序的控制权，先要覆盖返回地址。要覆盖返回地址，就必须知道返回地址在哪。那我们先看看正常的返回地址长啥样，看test函数中调用getbuf的下一行：</p><blockquote><p><code>(gdb） disas test</code>    #  查看test的汇编代码<br><img src="/2017/12/04/stack-overflow/retAddr.png" width="100%" height="100%"><br>getbuf函数调用完之后，程序应该返回0x08048dbe;跟我念，08,04,8d,be。<br>趁着还没忘记，赶紧回到上一张图高亮部分，从后往前看：08..04..8d..be！！！果然没错，就是要覆盖掉这里！<br>(至于为什么要倒过来，这可能就是little endian的哲学了吧。)</p></blockquote><p>那输入要从哪开始呢？前面getbuf的汇编告诉我们，字符数组从-0x28(%ebp)开始，可以用gdb里面的计算器算一算：</p><blockquote><p><code>(gdb) p $ebp-0x28</code><br><code>$1 = (void *) 0x55683588 &lt;_reserved+1037704&gt;</code><br><img src="/2017/12/04/stack-overflow/stringAddr.png" width="100%" height="100%"><br>就是说，要填满32个字节之后，还要再填16个字节才能覆盖返回地址。</p></blockquote><p>下面就面临一个问题了：覆盖了返回地址，去哪？<br><br><br><br><br><br><br><br></p><p>当然是去能够执行我给它的机器指令的地方啊！<br>显然，能够注入的指令的地址位置在0x55683588+，那跳转到哪比较合适呢？这时有两个选择：</p><ul><li>一个是buf[]数组里面，没有副作用，不会腐蚀前一个函数的栈结构，但是能写入的机器指令也很有限：总不能越过刚刚覆盖完的返回地址吧(回到过去杀掉自己的感觉?_?)。</li><li>另一个是“覆盖返回地址位置”之后，即0x556835b8+，不过这样很可能腐蚀前一个函数的栈结构，把别人家捣烂了还想不被发现，有点难度。而且别忘了test函数还有个门卫：<strong>volatile int local = uniqueval();</strong>，要是碰到了这个东西就更麻烦了(当然也不是不可以，用注入的机器指令恢复它的值就行。这就要看能不能摸透uniqueval了)。</li></ul><p>所以，说了这么多，还是尽量选第一个吧。毕竟我们的目标比较简单，目测注入代码也比较少。</p><blockquote><p>把这一坨东西丢进我“30行的cpp程序”中，去掉没用的信息(没错就是这么懒)<br><code>0x55683588 &lt;_reserved+1037704&gt;:    0x00    0x00    0x00    0x00    0x8d    0xe4    0xe2    0xf7</code><br><code>0x55683590 &lt;_reserved+1037712&gt;:    0x00    0x00    0x00    0x00    0xa8    0x8d    0x04    0x08</code><br><code>0x55683598 &lt;_reserved+1037720&gt;:    0x1f    0x6b    0x00    0x00    0xfc    0x1d    0xfb    0xf7</code><br><code>0x556835a0 &lt;_reserved+1037728&gt;:    0xe0    0x35    0x68    0x55    0xee    0x42    0xef    0xf7</code><br><code>0x556835a8 &lt;_reserved+1037736&gt;:    0x60    0x1d    0xfb    0xf7    0x7e    0xa5    0x04    0x08</code><br><code>0x556835b0 &lt;_reserved+1037744&gt;:    0xe0    0x35    0x68    0x55    0xbe    0x8d    0x04    0x08</code><br>得到<br><code>00 00 00 00 8d e4 e2 f7</code><br><code>00 00 00 00 a8 8d 04 08</code><br><code>1f 6b 00 00 fc 1d fb f7</code><br><code>e0 35 68 55 ee 42 ef f7</code><br><code>60 1d fb f7 7e a5 04 08</code><br><code>e0 35 68 55 be 8d 04 08</code><br>将最后一行修改为”e0 35 68 55 <strong>88 35 68 55</strong>“，最后转成字符输出到文件，执行程序时重定向一下(因为有些字符是键盘上没有的)，就可以跳转到指定位置啦。<br>(在正常情况下这段字符不应含有0x00，因为一般的gets在判断到有0x00对应的字符时，应该是会终止输入的。这里它没有这个限制)</p></blockquote><p>接下来就要写我们想执行的机器代码了，有些人一上来就拿起本IA32机器指令手册一条一条对照，想想就很激动。<br>我开始也是这么想的，结果发现完全可以：手工写汇编code.s + gcc -c code.s + objdump -d code.o，我倒。</p><p>手写汇编代码，主要包含的要点：</p><ul><li>修改返回值是主要目的：<br><strong>movl $0x1005b2b7,%eax</strong></li><li><p>模拟函数调用：<br><strong>pushl $0x8048dbe</strong><br><strong>pushl %ebp</strong><br><strong>movl %esp,%ebp</strong><br><strong>subl $0x38,%esp</strong><br>…<br>模拟函数调用是必要的：由于程序不知道我们修改了返回地址，在执行注入代码时，框架指针和栈指针和test的是一样的(认为我们已经返回到了test中)。如果要让<strong>注入代码</strong>的ret正常返回到test中，在ret之前就需要让栈的状态和getbuf的栈状态相同。如何做到相同？模拟getbuf的函数调用。<br>在模拟之前，首先要理解函数的调用过程：</p><ol><li><code>call，它的动作是push-and-jump(返回地址压栈，PC跳转);</code></li><li><code>push %ebp和mov %esp,%ebp(框架和栈指针合并);</code></li><li><code>sub %esp(为该函数分配栈空间，以便存放局部变量);</code></li></ol><p>由于我们第一步是通过hack了ret来实现的jump，所以并没有完全地按照call的动作，为了完全模拟，需要地址压栈，因此就不难理解第一行的<br><strong>pushl $0x8048dbe</strong>  (test中调用getbuf的下一行的地址)。</p></li><li>把控制权交回给test：<br><strong>leave</strong><br><strong>ret</strong><br>和getbuf函数的结束操作一样就行了:) 这里就顺便复习下leave和ret吧：<ol><li><code>leave是mov %ebp,%esp和pop %ebp(合并框架和栈指针，ebp回退到上一级函数状态)</code></li><li><code>ret是pop-and-jump(返回地址出栈，PC跳转)</code></li></ol></li></ul><p>最后的机器代码长这样：<br><img src="/2017/12/04/stack-overflow/machineCode.png" width="100%" height="100%"><br>从字符输入的起始位置替换：</p><pre><code>68 be 8d 04 08 55 89 e583 ec 38 b8 b7 b2 05 10c9 c3 00 00 fc 1d fb f7e0 35 68 55 ee 42 ef f760 1d fb f7 7e a5 04 08e0 35 68 55 88 35 68 55</code></pre><p>将这段机器指令用./hex2raw转换存到string.txt,<br><code>$ ./bufbomb -u bovik &lt; string.txt</code><br><img src="/2017/12/04/stack-overflow/finish1.png" width="100%" height="100%"></p><p>大功告成。</p><p><br><br><br><br><br><br><br><br><br></p><p>但是，还没有结束。<br>我们刚刚完成的是对一个“每次运行都使用相同栈地址”的演示程序的攻击。然鹅，在实际上，绝大多数的程序都会使用ASLR(address-space layout randomization)来作为保护。ASLR中的技术之一：栈随机化(stack randomization)能够有效防止栈溢出攻击。其主要表现为：在不同的时间运行同一段代码，里面使用到的栈地址都很可能不同。这可以通过”每次在程序执行前，在栈上分配一段随机大小的空间”来实现。</p><p>这样对于攻击者来说，在覆盖返回地址的时候不得不思考一个问题：-跳转到哪？-当然是能够执行我给它的机器指令的地方啊。-就是哪个地方？ -好像还真不好说，每次都不一样。</p><p>一般来说，考虑到程序的空间使用效率，栈随机化分配的空间不会太大。这时，就可以祭出nop-sled了：对于栈随机化程度有限，没有缓冲边界检查的程序，非常好用。那nop-sled到底该怎么用呢？在动手之前，我也有这个疑惑。<br>以下是我实际操作过程中的一些思考：<br>矛盾点在于，<strong>跳转的地址没办法确定为一个值(由于栈随机化)，而输入的攻击字符串却要求是固定的一个值。</strong>覆盖返回地址作为栈溢出攻击的第一步，如果不确定这个值就没法执行注入代码，汇编写得再牛也白搭。</p><p>尝试多次执行同一个程序的同一个函数，可以发现栈指针和框架指针的地址都在一定的范围内波动，如下图所示：<br><img src="/2017/12/04/stack-overflow/stack-randomization.png" width="50%" height="50%"><br>可以看到存放数据的buffer的地址也在一定范围内波动。</p><p>就是说<strong>跳转的地址要选一个定值，并且无论这个值处于栈结构的哪个位置，最终都能够执行注入的机器指令。</strong></p><p>这就容易想到该怎么用nop-sled了：把注入代码存放在buffer的末端，只要找到一个共用地址，并用nop作为背景填充(保证共用地址和注入代码地址之间都是nop)，程序跳转到共用地址后开始执行nop，滑落到注入代码部分，攻击就能够实现。如下图所示：<br><img src="/2017/12/04/stack-overflow/nop-sled.png" width="50%" height="50%"><br>当然这个共用地址也可以划到buffer外面去，不过这样会腐蚀更多的内容，恢复的难度也会相应增加。</p><p>下面简单提一提破坏恢复难度。显然，覆盖返回地址，同时也意味着腐蚀了返回地址之前的信息，再次搬出前面的图：<br><img src="/2017/12/04/stack-overflow/memory.png" width="50%" height="50%"></p><ul><li>saved %ebp被覆盖：这导致上一级框架指针位置信息丢失。如果不考虑这一点，必然导致栈结构腐蚀，很可能导致段错误。</li><li>saved %ebx或其他callee-saved的寄存器保存的值被覆盖：如果说上一级%ebp的信息还能通过%esp计算找回来，这种类型的信息一旦丢失，几乎无从找回，或者说找回的难度直接受”原程序计算出该值的方式“影响。要想恢复，汇编功底需要极其深厚。</li></ul><p>最后，总结一下栈溢出攻击的步骤：</p><ol><li>试探：看看有没有边界检查</li><li>确定覆盖点：在汇编中找到原返回地址，并和正常执行时的内存比对</li><li>分析注入代码存放位置：考虑注入代码长度、结构腐蚀的可恢复性</li><li>手写汇编代码：爱干啥干啥，如果要做到不留痕迹，恢复破坏的数据</li><li>汇编为机器指令，生成字符串：十六进制数字转字符</li><li>fire！</li></ol><p>最后的最后，要想避免自己的程序被别人用这种方式攻击，最简单的方法当然就是做好边界检查，让你写入32个字符就只能写入32个，多半个都不行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天沉迷于栈溢出，写篇文章记录一下。在此首先给CSAPP的作者Randal E. Bryant和David R. O’Hallaron献上我的膝盖，然后再给这本书的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/home.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配套网站&lt;/a&gt;和里面的&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/labs.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验室&lt;/a&gt;献上。。没有膝盖了，就点个赞吧。&lt;br&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="栈溢出" scheme="tangenta.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++读文件操作暗礁</title>
    <link href="tangenta.github.io/2017/10/26/fstream-trap/"/>
    <id>tangenta.github.io/2017/10/26/fstream-trap/</id>
    <published>2017-10-26T13:16:00.000Z</published>
    <updated>2018-01-13T10:51:37.062Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，先出一道题：<br>给定一个<strong>行数=3</strong>的文本文件，如何把每行的内容读出来存到std::vector<string>里面？<br><a id="more"></a></string></p><p>如果你的答案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">fstream <span class="title">in</span><span class="params">(<span class="string">"text"</span>)</span></span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line"><span class="built_in">string</span> buf;</div><div class="line"><span class="keyword">while</span>(in) &#123;</div><div class="line">  getline(in, buf);</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么我掐指一算：<br>你最近是不是感觉到你写的文件读写程序，行为有点怪异？<br>是不是忍不住发出惊叹“明明读完了啊，怎么多一行“？<br>是不是把fstream里面有关good/eof/fail/bad的文档全看了一遍，还是找不到问题在哪？<br>是不是才爬个5楼，就觉得胸闷气短…<br>咳，回到正题：如果在最后加一句</p><pre><code>cout&lt;&lt;v.size()&lt;&lt;&quot;\n&quot;;</code></pre><p>发现结果是4。分析一下原因：在in&gt;&gt;buf读取文件最后一行的时候，状态为goodbit，v.push_back正常读入最后一行;再次判断循环条件，由于goodbit，进入循环;这时in&gt;&gt;tmp就开始出问题了，它读到了文件结束符eof。然而我们的buf可不管，读不到东西也push_back，这就造成size比行数大1的结果。<br>总结起来一句话就是：<strong>“从文件读取到缓冲”和”从缓冲输入到容器”之间没有空隙，即无条件连接。</strong><br>显然，while的条件判断起作用的时机晚了。一个解决方案是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;<span class="comment">//solution1</span></div><div class="line">  getline(in, buf);</div><div class="line">  <span class="keyword">if</span> (!in) <span class="keyword">break</span>;</div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其等价于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(getline(in, buf)) &#123;<span class="comment">//solution2</span></div><div class="line">  v.push_back(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二个解决方案也是C++中的惯用法(idiom)，更为简洁、美观。</p><pre><code>return;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，先出一道题：&lt;br&gt;给定一个&lt;strong&gt;行数=3&lt;/strong&gt;的文本文件，如何把每行的内容读出来存到std::vector&lt;string&gt;里面？&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>邂逅异或链表</title>
    <link href="tangenta.github.io/2017/10/22/xorLinkedList/"/>
    <id>tangenta.github.io/2017/10/22/xorLinkedList/</id>
    <published>2017-10-22T13:39:00.000Z</published>
    <updated>2018-01-13T10:51:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。</p><a id="more"></a><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>异或链表的原理是，表中的每个节点跟单链表一样，都有俩区域: 数据域和指针域。这个指针域就厉害了，存的不是别人，而是它前后节点地址的异或。得益于异或运算的性质，任何时候只需要知道链表中相邻的两个节点地址，就可以访问其中的每一个节点。以前只听过异或运算能用来实现inplace swap(不需要额外的空间就可以交换两个变量)，没想到还能应用到链表中。</p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>看起来很简单嘛，内嵌一个节点类，复制控制函数压死，再上容器四大护法增删改查，一切都很顺利……嗯？这段怎么这么deja vu？定睛一看，这几段都有遍历操作，而每次遍历都用到两个节点指针，一前一后一个while，内部再一个判断一个break。想起scott meyers教导我们，代码复制不可取。今天复制一段代码，明天就会复制一个文件，后天……跑题了，总之作为一个有理想的青年，代码复制要不得。想到这里，我这暴脾气就上来了，一顿操作从删掉重写到发朋友圈，丝毫不拖泥带水，思考时被我拔掉的头发也不算特别多。这个是效果：</p><p>修改前:<br><img src="/2017/10/22/xorLinkedList/2017-10-22-1.png" width="50%" height="50%"></p><p>修改后：<br><img src="/2017/10/22/xorLinkedList/2017-10-22-2.png" width="50%" height="50%"></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-3.png" width="100%" height="100%"></p><p>将判断条件、迭代调整、返回值做成函数调用形式，达到用模板参数传递”功能“(函数指针、函数对象或lambda表达式)的目的。简单说就是从外部把功能嵌入函数体中。</p><p>一个traverse函数打天下 =_=</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>敲定最后一个lambda表达式，好不容易松了口气，正欣赏着”成果”，不知道《C++ template》的哪一个混蛋作者在我脑子里喊了句”code bloat”。</p><p>。。。</p><p>。。。</p><p>我、lambda表达式们大眼瞪小眼，这时我才发现一个个的lambda(s?)，每个类型都不相同，这意味着几乎每次使用到traverse()都要实例化，我仿佛已经看到了目标文件的臃肿。再一细看，还把traverse写成了public。典型滥用模板的例子，哎。</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>我不甘心啊！伴随着更多头发的飘落，”遍历“这个词终于让我联想到了”迭代器“。是啊，为什么不搞一个迭代器呢？<br>for(List<t>::iterator i = v.begin(); i != v.end(); ++i) {…}，<br>多么优雅。但是迭代器内部的数据一般只有一个指针，而异或链表的遍历必须由两个指针贴着走。那一个迭代器包含两个指针行不行呢？开始尝试：</t></p><p><img src="/2017/10/22/xorLinkedList/2017-10-22-4.png" width="100%" height="100%"><br>解引用操作和指针操作都取ptr2，{ptr1 = 0; ptr2 = head}对应begin，{ptr1 = tail, ptr2 = 0}对应end，没毛病。</p><p>(中间踩了点小坑，这里省略一万字，”explicit你都干了些什么”、”包含编译模型之凝视”、”const成员函数之谜”、”多余&amp;引发的运行时血案”之类的不再细叙)</p><p>最终效果如下：<br>(这是获得第pos-1个节点和第pos个节点指针的具体实现)<br><img src="/2017/10/22/xorLinkedList/2017-10-22-5.png" width="100%" height="100%"><br>很明显，无论是易读性、可维护性都提高了不少。</p><p><a href="https://gitee.com/tangenta/XorList.git" target="_blank" rel="external">XorList源码</a></p><p>虽然简陋版迭代器是写出来了，但不知道它和stl算法的结合情况如何。哪天出乱子了我再收拾它去。</p><pre><code>return (待续||不续);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构课上刷轮子哥，看到一条关于链表的回答，意思大概是 “可以用猥琐的方法把节点的前驱后继地址压缩为一个值，实现双向遍历”。必应搜索一波，于是课还没上完，满脑子都是”异或链表”的骚操作。想也正好，刚刚布置的链表作业又没写着”不能用异或链表”这几个字，咱说干就干。&lt;/p&gt;
    
    </summary>
    
      <category term="实践" scheme="tangenta.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="c++" scheme="tangenta.github.io/tags/c/"/>
    
      <category term="stl" scheme="tangenta.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="tangenta.github.io/2017/09/28/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>tangenta.github.io/2017/09/28/git学习笔记/</id>
    <published>2017-09-28T07:58:00.000Z</published>
    <updated>2018-01-13T10:50:30.024Z</updated>
    
    <content type="html"><![CDATA[<p>用作记录，方便查阅<br><a id="more"></a></p><h2 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git init</td><td>在当前目录初始化仓库</td></tr></tbody></table><h2 id="提交-上传文件"><a href="#提交-上传文件" class="headerlink" title="提交/上传文件"></a>提交/上传文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git add fileName</td><td>将工作区文件添加到暂存区</td></tr><tr><td> $ git commit -m “some comment”</td><td>将暂存区文件添加到版本库</td></tr></tbody></table><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git rm fileName</td><td>删掉暂存区的文件</td></tr></tbody></table><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git status</td><td>显示仓库当前状态</td></tr><tr><td> $ git diff fileName</td><td>显示工作区和版本库的差异</td></tr><tr><td> $ git log [–pretty=oneline] [–graph] [–abbrev-commit]</td><td>显示版本库内的commit历史记录 [以单行的形式显示][显示分支图]</td></tr><tr><td> $ git reflog</td><td>显示版本变更的历史命令</td></tr><tr><td> $ git branch</td><td>查看当前所在的分支</td></tr><tr><td> $ git stash list</td><td>查看被储存的工作区列表</td></tr><tr><td> $ git remote -v</td><td>查看远程库的[详细]信息</td></tr><tr><td> $ git tag</td><td>查看所有标签</td></tr><tr><td> $ git show <tagname></tagname></td><td>查看某一个标签的信息</td></tr></tbody></table><h2 id="版本设置"><a href="#版本设置" class="headerlink" title="版本设置"></a>版本设置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git reset –hard HEAD^</td><td>HEAD为当前版本，每一个”^”代表上一个版本。HEAD~n代表上n个版本</td></tr><tr><td> $ git reset –hard commitId</td><td>将当前版本设置到版本号为“commitId”的版本</td></tr></tbody></table><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout – fileName</td><td>使工作区文件撤销到(暂存区或版本库)的状态</td></tr><tr><td> $ git reset HEAD fileName</td><td>使暂存区的文件撤销到版本库的状态</td></tr></tbody></table><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ ssh-keygen -t rsa -C “email@example.com”</td><td>获取ssh key</td></tr><tr><td> $ git remote add origin git@serverName:path/repoName.git</td><td>关联远程库</td></tr><tr><td> $ git remote rm origin</td><td>删除origin远程库</td></tr><tr><td> $ git push -u origin master</td><td>第一次推送master分支的所有内容</td></tr><tr><td> $ git push origin master</td><td>推送最新修改</td></tr><tr><td> $ git clone git@serverName:path/repoName.git</td><td>克隆远程仓库到本地</td></tr><tr><td> $ git push origin master</td><td>把本地的master分支推送到远程origin分支上</td></tr></tbody></table><h2 id="创建-合并-删除分支"><a href="#创建-合并-删除分支" class="headerlink" title="创建/合并/删除分支"></a>创建/合并/删除分支</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git checkout -b dev origin/dev</td><td>创建一个dev分支，并关联远程的orgin/dev分支</td></tr><tr><td> $ git branch –set-upstream dev origin/dev</td><td>设置本地dev于远程仓库origin/dev关联</td></tr><tr><td> $ git pull</td><td>将本地文件与远程仓库同步</td></tr><tr><td> $ git checkout -b dev</td><td>创建并切换到分支dev</td></tr><tr><td> $ git branch dev</td><td>创建分支dev</td></tr><tr><td> $ git checkout dev</td><td>切换到分支dev</td></tr><tr><td> $ git merge dev</td><td>把分支dev合并到当前分支</td></tr><tr><td> $ git branch -d dev</td><td>删除已被合并的分支dev</td></tr><tr><td> $ git branch -D dev</td><td>强制删除未合并的分支dev</td></tr><tr><td> $ git merge –no-ff -m “some comments” dev</td><td>以创建一个commit的方式合并dev分支</td></tr></tbody></table><h2 id="工作区临时储存-恢复"><a href="#工作区临时储存-恢复" class="headerlink" title="工作区临时储存/恢复"></a>工作区临时储存/恢复</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git stash</td><td>储存当前工作区状态，并清空</td></tr><tr><td> $ git stash apply [stash@{n}]</td><td>恢复上一个被储存的工作区 [第n个储存的工作区]</td></tr><tr><td> $ git stash drop</td><td>删除stash list</td></tr><tr><td> $ git stash pop</td><td>恢复工作区，并删除stash list</td></tr></tbody></table><h2 id="标签创建-删除"><a href="#标签创建-删除" class="headerlink" title="标签创建/删除"></a>标签创建/删除</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git tag v1.0 [commit Id]</td><td>为当前最新的提交创建名为v1.0的标签 [对给定提交id创建]</td></tr><tr><td> $ git tag -a v0.1 -m “some comments” commitId</td><td>-a指定名字，-m指定说明文字</td></tr><tr><td> $ git tag -d v0.1</td><td>删除名为v0.1的标签</td></tr><tr><td> $ git push origin <tagname></tagname></td><td>将tagName标签推送到远程</td></tr><tr><td> $ git push origin –tags</td><td>将所有未推送的标签推送到远程</td></tr><tr><td> $ git push origin :refs/tags/v0.9</td><td>删除远程名为v0.9的标签</td></tr></tbody></table><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td> $ git config –global color.ui true</td><td>显示颜色</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用作记录，方便查阅&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
      <category term="git" scheme="tangenta.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GDB常用命令汇总</title>
    <link href="tangenta.github.io/2017/09/27/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>tangenta.github.io/2017/09/27/GDB常用命令汇总/</id>
    <published>2017-09-27T12:36:00.000Z</published>
    <updated>2018-01-13T10:50:06.856Z</updated>
    
    <content type="html"><![CDATA[<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><title>GDB常用命令汇总</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="generator" content="Org-mode"><style type="text/css"> <!--/*--><![CDATA[/*><!--*/  .title  { text-align: center; }  .todo   { font-family: monospace; color: red; }  .done   { color: green; }  .tag    { background-color: #eee; font-family: monospace;            padding: 2px; font-size: 80%; font-weight: normal; }  .timestamp { color: #bebebe; }  .timestamp-kwd { color: #5f9ea0; }  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }  .center { margin-left: auto; margin-right: auto; text-align: center; }  .underline { text-decoration: underline; }  #postamble p, #preamble p { font-size: 90%; margin: .2em; }  p.verse { margin-left: 3%; }  pre {    border: 1px solid #ccc;    box-shadow: 3px 3px 3px #eee;    padding: 8pt;    font-family: monospace;    overflow: auto;    margin: 1.2em;  }  pre.src {    position: relative;    overflow: visible;    padding-top: 1.2em;  }  pre.src:before {    display: none;    position: absolute;    background-color: white;    top: -10px;    right: 10px;    padding: 3px;    border: 1px solid black;  }  pre.src:hover:before { display: inline;}  pre.src-sh:before    { content: 'sh'; }  pre.src-bash:before  { content: 'sh'; }  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }  pre.src-R:before     { content: 'R'; }  pre.src-perl:before  { content: 'Perl'; }  pre.src-java:before  { content: 'Java'; }  pre.src-sql:before   { content: 'SQL'; }  table { border-collapse:collapse; }  caption.t-above { caption-side: top; }  caption.t-bottom { caption-side: bottom; }  td, th { vertical-align:top;  }  th.right  { text-align: center;  }  th.left   { text-align: center;   }  th.center { text-align: center; }  td.right  { text-align: right;  }  td.left   { text-align: left;   }  td.center { text-align: center; }  dt { font-weight: bold; }  .footpara:nth-child(2) { display: inline; }  .footpara { display: block; }  .footdef  { margin-bottom: 1em; }  .figure { padding: 1em; }  .figure p { text-align: center; }  .inlinetask {    padding: 10px;    border: 2px solid gray;    margin: 10px;    background: #ffffcc;  }  #org-div-home-and-up   { text-align: right; font-size: 70%; white-space: nowrap; }  textarea { overflow-x: auto; }  .linenr { font-size: smaller }  .code-highlighted { background-color: #ffff00; }  .org-info-js_info-navigation { border-style: none; }  #org-info-js_console-label    { font-size: 10px; font-weight: bold; white-space: nowrap; }  .org-info-js_search-highlight    { background-color: #ffff00; color: #000000; font-weight: bold; }  /*]]>*/--></style><script type="text/javascript">/*@licstart  The following is the entire license notice for theJavaScript code in this tag.Copyright (C) 2012-2013 Free Software Foundation, Inc.The JavaScript code in this tag is free software: you canredistribute it and/or modify it under the terms of the GNUGeneral Public License (GNU GPL) as published by the Free SoftwareFoundation, either version 3 of the License, or (at your option)any later version.  The code is distributed WITHOUT ANY WARRANTY;without even the implied warranty of MERCHANTABILITY or FITNESSFOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.As additional permission under GNU GPL version 3 section 7, youmay distribute non-source (e.g., minimized or compacted) forms ofthat code without the copy of the GNU GPL normally required bysection 4, provided you include this license notice and a URLthrough which recipients can access the Corresponding Source.@licend  The above is the entire license noticefor the JavaScript code in this tag.*/<!--/*--><![CDATA[/*><!--*/ function CodeHighlightOn(elem, id) {   var target = document.getElementById(id);   if(null != target) {     elem.cacheClassElem = elem.className;     elem.cacheClassTarget = target.className;     target.className = "code-highlighted";     elem.className   = "code-highlighted";   } } function CodeHighlightOff(elem, id) {   var target = document.getElementById(id);   if(elem.cacheClassElem)     elem.className = elem.cacheClassElem;   if(elem.cacheClassTarget)     target.className = elem.cacheClassTarget; }/*]]>*///--></script></head><body><p>用作记录，方便查阅</p><a id="more"></a><div id="content"><div id="table-of-contents"><h1>Table of Contents</h1><div id="text-table-of-contents"><ul><li><a href="#sec-1">1. Starting</a></li><li><a href="#sec-2">2. Running and stopping</a></li><li><a href="#sec-3">3. Breakpoints</a></li><li><a href="#sec-4">4. Execution</a></li><li><a href="#sec-5">5. Examining code</a></li><li><a href="#sec-6">6. Examining data</a></li><li><a href="#sec-7">7. Useful information</a></li></ul></div></div><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">Command</td><td class="left">Effect</td></tr></tbody></table><div id="outline-container-sec-1" class="outline-1"><h1 id="sec-1"><span class="section-number-1">1</span> Starting</h1><div class="outline-text-1" id="text-1"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">gdb</td><td class="left">&#xa0;</td></tr><tr><td class="left">gdb &lt;file&gt;</td><td class="left">&#xa0;</td></tr></tbody></table></div></div><div id="outline-container-sec-2" class="outline-1"><h1 id="sec-2"><span class="section-number-1">2</span> Running and stopping</h1><div class="outline-text-1" id="text-2"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">run</td><td class="left">Run program</td></tr><tr><td class="left">run 1 2 3</td><td class="left">Run program with command-line arguments 1 2 3</td></tr><tr><td class="left">kill</td><td class="left">Stop the program</td></tr><tr><td class="left">quit</td><td class="left">Exit gdb</td></tr><tr><td class="left">Ctrl-d</td><td class="left">Exit gdb</td></tr></tbody></table><p>Note: Ctrl-C does not exit from gdb, but halts the currentgdb command</p></div></div><div id="outline-container-sec-3" class="outline-1"><h1 id="sec-3"><span class="section-number-1">3</span> Breakpoints</h1><div class="outline-text-1" id="text-3"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">break sum</td><td class="left">Set breakpoint at the entry to function sum</td></tr><tr><td class="left">break *0x80483c3</td><td class="left">Set breakpoint at address 0x80483c3</td></tr><tr><td class="left">delete 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">disable 1</td><td class="left">Delete breakpoint 1</td></tr><tr><td class="left">enable 1</td><td class="left">Enable breakpoint 1</td></tr><tr><td class="left">delete</td><td class="left">Delete all breakpoints</td></tr><tr><td class="left">clear sum</td><td class="left">clear sum</td></tr></tbody></table></div></div><div id="outline-container-sec-4" class="outline-1"><h1 id="sec-4"><span class="section-number-1">4</span> Execution</h1><div class="outline-text-1" id="text-4"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">stepi</td><td class="left">Execute one instruction</td></tr><tr><td class="left">stepi 4</td><td class="left">Execute four instructions</td></tr><tr><td class="left">nexti</td><td class="left">Like stepi, but proceed through function calls without stopping</td></tr><tr><td class="left">step</td><td class="left">Execute one C statement</td></tr><tr><td class="left">continue</td><td class="left">Resume execution until the next breakpoint</td></tr><tr><td class="left">until 3</td><td class="left">Continue executing until program hits breakpoint 3</td></tr><tr><td class="left">finish</td><td class="left">Resume execution until current function returns</td></tr><tr><td class="left">call sum(1,2)</td><td class="left">Call sum(1,2) and print return value</td></tr></tbody></table></div></div><div id="outline-container-sec-5" class="outline-1"><h1 id="sec-5"><span class="section-number-1">5</span> Examining code</h1><div class="outline-text-1" id="text-5"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">disas</td><td class="left">Disassemble current function</td></tr><tr><td class="left">disas sum</td><td class="left">Disassemble function sum</td></tr><tr><td class="left">disas 0x80483b7</td><td class="left">Disassemble function around 0x80483b7</td></tr><tr><td class="left">disas 0x80483b7 0x80483c7</td><td class="left">Disassemble code within specified address range</td></tr><tr><td class="left">print /x $rip</td><td class="left">Print program counter in hex</td></tr><tr><td class="left">print /d $rip</td><td class="left">Print program counter in decimal</td></tr><tr><td class="left">print /t $rip</td><td class="left">Print program counter in binary</td></tr></tbody></table></div></div><div id="outline-container-sec-6" class="outline-1"><h1 id="sec-6"><span class="section-number-1">6</span> Examining data</h1><div class="outline-text-1" id="text-6"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print /d $rax</td><td class="left">Print contents of %rax in decimal</td></tr><tr><td class="left">print /x $rax</td><td class="left">Print contents of %rax in hex</td></tr><tr><td class="left">print /t $rax</td><td class="left">Print contents of %rax in binary</td></tr><tr><td class="left">print /d (int)$rax</td><td class="left">Print contents of %rax in decimal after sign-extending lower 32-bits.</td></tr></tbody></table><p>You need this to print 32-bit, negative numbers stored in the lower 32 bits of %rax.For example, if the lower 32-bits of %rax store 0xffffffff, you will see: </p><pre class="example">(gdb) print $rax$1 = 4294967295(gdb) print (int)$rax$2 = -1</pre><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">print 0x100</td><td class="left">Print decimal representation of 0x100</td></tr><tr><td class="left">print /x 555</td><td class="left">Print hex representation of 555</td></tr><tr><td class="left">print /x ($rsp+8)</td><td class="left">Print (contents of %rsp) + 8 in hex</td></tr><tr><td class="left">print *(int *) 0xbffff890</td><td class="left">Print integer at address 0xbffff890</td></tr><tr><td class="left">print *(int *) ($rsp+8)</td><td class="left">Print integer at address %rsp + 8</td></tr><tr><td class="left">print (char *) 0xbfff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/w   0xbffff890</td><td class="left">Examine (4-byte) word starting at address 0xbffff890</td></tr><tr><td class="left">x/w   $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp</td></tr><tr><td class="left">x/wd  $rsp</td><td class="left">Examine (4-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/2w  $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp</td></tr><tr><td class="left">x/2wd $rsp</td><td class="left">Examine two (4-byte) words starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/g   $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp.</td></tr><tr><td class="left">x/gd  $rsp</td><td class="left">Examine (8-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td class="left">x/a   $rsp</td><td class="left">Examine address in $rsp. Print as offset from previous global symbol.</td></tr><tr><td class="left">x/s   0xbffff890</td><td class="left">Examine a string stored at 0xbffff890</td></tr><tr><td class="left">x/20b sum</td><td class="left">Examine first 20 opcode bytes of function sum</td></tr><tr><td class="left">x/10i sum</td><td class="left">Examine first 10 instructions of function sum</td></tr></tbody></table><p>(Note: the format string for the `x' command has the general form x/[NUM][SIZE][FORMAT] where</p><pre class="example">NUM  = number of objects to display.SIZE = size of each object (b=byte, h=half-word, w=word, g=giant (quad-word))FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)</pre><p>  If you don't specify SIZE or FORMAT, either a default value, or the last  value you specified in a previous `print' or `x' command is used.)</p></div></div><div id="outline-container-sec-7" class="outline-1"><h1 id="sec-7"><span class="section-number-1">7</span> Useful information</h1><div class="outline-text-1" id="text-7"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"></colgroup><tbody><tr><td class="left">backtrace</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">where</td><td class="left">Print the current address and stack backtrace</td></tr><tr><td class="left">info program</td><td class="left">Print current status of the program)</td></tr><tr><td class="left">info functions</td><td class="left">Print functions in program</td></tr><tr><td class="left">info stack</td><td class="left">Print backtrace of the stack)</td></tr><tr><td class="left">info frame</td><td class="left">Print information about the current stack frame</td></tr><tr><td class="left">info registers</td><td class="left">Print registers and their contents</td></tr><tr><td class="left">info breakpoints</td><td class="left">Print status of user-settable breakpoints</td></tr><tr><td class="left">display /FMT EXPR</td><td class="left">Print expression EXPR using format FMT every time GDB stops</td></tr><tr><td class="left">undisplay</td><td class="left">Turn off display mode</td></tr><tr><td class="left">help</td><td class="left">Get information about gdb</td></tr></tbody></table></div></div></div><div id="postamble" class="status"><p class="creator"><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 24.5.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)</p><p class="validation"><a href="http://validator.w3.org/check?uri=referer" target="_blank" rel="external">Validate</a></p></div></body></html>]]></content>
    
    <summary type="html">
    
      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot; xml:lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;GDB常用命令汇总&lt;/title&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;meta name=&quot;generator&quot; content=&quot;Org-mode&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
 &lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: &#39;sh&#39;; }
  pre.src-bash:before  { content: &#39;sh&#39;; }
  pre.src-emacs-lisp:before { content: &#39;Emacs Lisp&#39;; }
  pre.src-R:before     { content: &#39;R&#39;; }
  pre.src-perl:before  { content: &#39;Perl&#39;; }
  pre.src-java:before  { content: &#39;Java&#39;; }
  pre.src-sql:before   { content: &#39;SQL&#39;; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]&gt;*/--&gt;
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
&lt;!--/*--&gt;&lt;![CDATA[/*&gt;&lt;!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = &quot;code-highlighted&quot;;
     elem.className   = &quot;code-highlighted&quot;;
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]&gt;*///--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;用作记录，方便查阅&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="tangenta.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gdb" scheme="tangenta.github.io/tags/gdb/"/>
    
      <category term="cheatsheet" scheme="tangenta.github.io/tags/cheatsheet/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令实例 (长期更新)</title>
    <link href="tangenta.github.io/2017/09/24/Linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>tangenta.github.io/2017/09/24/Linux命令实例（长期更新）/</id>
    <published>2017-09-24T13:10:00.000Z</published>
    <updated>2018-01-13T10:49:29.383Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用linux命令<br><a id="more"></a></p><h2 id="文本文件在windows和linux之间的相互转换"><a href="#文本文件在windows和linux之间的相互转换" class="headerlink" title="文本文件在windows和linux之间的相互转换"></a>文本文件在windows和linux之间的相互转换</h2><p>差异：windows下的文本文件的编码方式默认采用的是GBK，而linux默认采用utf-8，因此同一文件在两种操作系统下可能会出现中文乱码的现象。另外，windows文件的换行符为’/r/n’，而linux文件则为’/n’，也会导致一系列奇怪问题的产生。</p><p>windows -&gt; linux: 多出来的 <strong>/r</strong> 文件换行符在vi下以 <strong>^M</strong> 的形式呈现。</p><ul><li><p>移除 <strong>^M</strong>: <code>sed -i &#39;s/^M//g&#39; fileName</code></p><blockquote><p><strong>-i</strong>  : 直接修改文件内容，不输出<br><strong>s</strong>  : 取代<br><strong>^M</strong> : 通过ctrl+v ctrl+m 输入<br><strong>g</strong>  : 应用于全局<br>‘s/匹配文本/替换文本/g’</p></blockquote></li><li><p>添加<strong>^M</strong>: <code>sed -i &#39;s/$/^M/g&#39; fileName</code></p><blockquote><p><strong>$</strong>: 匹配行末</p></blockquote></li><li><p>转换编码方式: <code>iconv -f gbk -t utf8 fileName &gt; newFileName</code></p><blockquote><p><strong>-f</strong>: from<br> <strong>-t</strong>: to</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用linux命令&lt;br&gt;
    
    </summary>
    
      <category term="杂类" scheme="tangenta.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="linux" scheme="tangenta.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
